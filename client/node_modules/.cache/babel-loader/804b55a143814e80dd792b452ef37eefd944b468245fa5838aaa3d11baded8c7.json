{"ast":null,"code":"/**\n * Service de monitoring client\n * Collecte et envoie des métriques de performance, d'utilisation et d'erreurs\n * au backend pour analyse et affichage dans le tableau de bord de monitoring\n */import axios from'axios';// Configuration de base\nconst API_URL=process.env.REACT_APP_API_URL||'http://localhost:5000/api';const METRICS_ENDPOINT=`${API_URL}/monitoring/metrics`;const PERFORMANCE_ENDPOINT=`${API_URL}/monitoring/performance`;const ERROR_ENDPOINT=`${API_URL}/monitoring/errors`;const USER_TRACKING_ENDPOINT=`${API_URL}/monitoring/user-tracking`;const API_METRICS_ENDPOINT=`${API_URL}/monitoring/api-metrics`;// Configuration des intervalles d'envoi de données\nconst BATCH_INTERVAL=30000;// 30 secondes entre chaque envoi de lot de métriques\nconst MAX_BATCH_SIZE=50;// Nombre maximum de métriques par lot\n// Files d'attente pour les différents types de métriques\nlet performanceMetrics=[];let errorMetrics=[];let userMetrics=[];let apiMetrics=[];// Statistiques d'API en temps réel (pour le dashboard)\nlet apiStats={callCount:0,errorCount:0,cacheHitCount:0,fallbackCount:0,retryCount:0,responseTimeTotal:0,longestResponseTime:0,endpoints:{},lastUpdated:Date.now(),// Données horodatées pour les graphiques\ntimeSeriesData:{timestamps:[],responseTimes:[],errorRates:[],cacheHitRates:[]}};// Map des debounces des appels API pour éviter les appels en double\nconst apiDebounceMap=new Map();// Indicateurs d'état\nlet isInitialized=false;let isSending=false;let sessionId=null;/**\n * Initialise le service de monitoring\n */const initialize=()=>{if(isInitialized)return;// Générer un ID de session unique\nsessionId=`${Date.now()}-${Math.random().toString(36).substring(2,15)}`;// Configurer l'envoi périodique de métriques\nsetInterval(sendBatchedMetrics,BATCH_INTERVAL);// Écouter les événements de performance du navigateur\nif(window.PerformanceObserver){try{// Observer les mesures de performance Web Vitals\nconst perfObserver=new PerformanceObserver(list=>{list.getEntries().forEach(entry=>{if(['CLS','FID','LCP','FCP','TTFB'].includes(entry.name)){trackBrowserPerformance(entry.name,entry.value,entry);}});});perfObserver.observe({type:'largest-contentful-paint',buffered:true});perfObserver.observe({type:'first-input',buffered:true});perfObserver.observe({type:'layout-shift',buffered:true});perfObserver.observe({type:'paint',buffered:true});}catch(e){console.warn('PerformanceObserver not fully supported:',e);}}// Intercepter les erreurs non gérées\nwindow.addEventListener('error',event=>{trackError('unhandled_exception',{message:event.message,filename:event.filename,lineno:event.lineno,colno:event.colno,stack:event.error?event.error.stack:null});});// Intercepter les rejets de promesses non gérés\nwindow.addEventListener('unhandledrejection',event=>{trackError('unhandled_promise_rejection',{reason:event.reason?event.reason.toString():'Unknown reason',stack:event.reason&&event.reason.stack?event.reason.stack:null});});// Marquer comme initialisé\nisInitialized=true;// Envoyer une métrique d'initialisation\ntrackGenericMetric('monitoring_initialized',{userAgent:navigator.userAgent,screenSize:`${window.innerWidth}x${window.innerHeight}`,timestamp:Date.now()});};/**\n * Envoie les métriques accumulées au serveur\n */const sendBatchedMetrics=async()=>{if(isSending||performanceMetrics.length===0&&errorMetrics.length===0&&userMetrics.length===0&&apiMetrics.length===0){return;}isSending=true;try{// Collecter les métriques actuelles et vider les files d'attente\nconst metricsToSend={sessionId,timestamp:Date.now(),performance:[...performanceMetrics].slice(0,MAX_BATCH_SIZE),errors:[...errorMetrics].slice(0,MAX_BATCH_SIZE),userActivity:[...userMetrics].slice(0,MAX_BATCH_SIZE),apiCalls:[...apiMetrics].slice(0,MAX_BATCH_SIZE)};// Vider les files d'attente des métriques envoyées\nperformanceMetrics=performanceMetrics.slice(MAX_BATCH_SIZE);errorMetrics=errorMetrics.slice(MAX_BATCH_SIZE);userMetrics=userMetrics.slice(MAX_BATCH_SIZE);apiMetrics=apiMetrics.slice(MAX_BATCH_SIZE);// Envoyer les métriques au backend\nawait axios.post(METRICS_ENDPOINT,metricsToSend);// Mettre à jour les statistiques d'API pour le dashboard\nupdateApiStats();}catch(error){// En cas d'erreur, stocker localement pour réessayer plus tard\nconsole.warn('Failed to send metrics to server:',error);// Stocker jusqu'à 1000 métriques localement en cas de problème de connexion\nconst storedMetrics=JSON.parse(localStorage.getItem('pendingMetrics')||'[]');if(storedMetrics.length<1000){localStorage.setItem('pendingMetrics',JSON.stringify([...storedMetrics,{timestamp:Date.now(),metrics:metricsToSend}]));}}finally{isSending=false;}};/**\n * Suivi des performances d'un composant (temps de rendu, chargement, etc.)\n * @param {string} componentName - Nom du composant\n * @param {number} duration - Durée en millisecondes\n * @param {Object} metadata - Métadonnées supplémentaires\n */const trackComponentPerformance=function(componentName,duration){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();performanceMetrics.push({type:'component_performance',component:componentName,duration,timestamp:Date.now(),...metadata});// Si des métriques clés sont lentes, envoyer immédiatement\nif(duration>1000&&componentName.includes('Calculator')){sendBatchedMetrics();}};/**\n * Suivi du démontage d'un composant (fin de session d'utilisation)\n * @param {string} componentName - Nom du composant\n * @param {Object} sessionData - Données de la session (durée, actions, etc.)\n */const trackComponentUnmount=function(componentName){let sessionData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!isInitialized)initialize();performanceMetrics.push({type:'component_unmount',component:componentName,timestamp:Date.now(),...sessionData});};/**\n * Suivi des performances du navigateur (Web Vitals)\n * @param {string} metricName - Nom de la métrique (CLS, FID, LCP, etc.)\n * @param {number} value - Valeur de la métrique\n * @param {Object} entry - Entrée de performance originale\n */const trackBrowserPerformance=function(metricName,value){let entry=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();performanceMetrics.push({type:'browser_performance',metricName,value,timestamp:Date.now(),url:window.location.href,details:entry});};/**\n * Suivi des performances d'API\n * @param {string} endpoint - Endpoint de l'API appelé\n * @param {number} duration - Durée en millisecondes\n * @param {Object} metadata - Métadonnées (statut, taille de la réponse, etc.)\n */const trackApiPerformance=function(endpoint,duration){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();apiMetrics.push({type:'api_performance',endpoint,duration,timestamp:Date.now(),...metadata});// Mise à jour des statistiques en temps réel\napiStats.callCount++;apiStats.responseTimeTotal+=duration;apiStats.longestResponseTime=Math.max(apiStats.longestResponseTime,duration);// Mise à jour des données par endpoint\nif(!apiStats.endpoints[endpoint]){apiStats.endpoints[endpoint]={callCount:0,errorCount:0,cacheHitCount:0,responseTimeTotal:0,avgResponseTime:0};}apiStats.endpoints[endpoint].callCount++;apiStats.endpoints[endpoint].responseTimeTotal+=duration;apiStats.endpoints[endpoint].avgResponseTime=apiStats.endpoints[endpoint].responseTimeTotal/apiStats.endpoints[endpoint].callCount;// Mise à jour des données temporelles pour les graphiques\nupdateTimeSeriesData();// Si un appel API est particulièrement lent, signaler immédiatement\nif(duration>3000){sendBatchedMetrics();}};/**\n * Suivi des erreurs\n * @param {string} errorType - Type d'erreur\n * @param {Object} errorDetails - Détails de l'erreur\n */const trackError=function(errorType){let errorDetails=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!isInitialized)initialize();errorMetrics.push({type:'error',errorType,timestamp:Date.now(),url:window.location.href,...errorDetails});// Les erreurs sont envoyées immédiatement\nsendBatchedMetrics();};/**\n * Suivi des interactions utilisateur\n * @param {string} componentName - Nom du composant\n * @param {string} action - Action effectuée\n * @param {Object} metadata - Métadonnées supplémentaires\n */const trackUserInteraction=function(componentName,action){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();userMetrics.push({type:'user_interaction',component:componentName,action,timestamp:Date.now(),url:window.location.href,...metadata});};/**\n * Suivi de l'engagement utilisateur sur la durée\n * @param {string} feature - Fonctionnalité utilisée\n * @param {Object} engagementData - Données d'engagement\n */const trackUserEngagement=function(feature){let engagementData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!isInitialized)initialize();userMetrics.push({type:'user_engagement',feature,timestamp:Date.now(),url:window.location.href,...engagementData});};/**\n * Suivi d'une métrique générique\n * @param {string} metricName - Nom de la métrique\n * @param {Object} data - Données associées\n */const trackGenericMetric=function(metricName){let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!isInitialized)initialize();performanceMetrics.push({type:'generic',metricName,timestamp:Date.now(),...data});};/**\n * Enregistre une erreur d'API\n * @param {string} endpoint - Endpoint de l'API\n * @param {Object} error - Objet d'erreur\n * @param {Object} metadata - Métadonnées supplémentaires\n */const logApiError=function(endpoint,error){var _error$response;let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();errorMetrics.push({type:'api_error',endpoint,errorMessage:error.message||'Unknown error',errorCode:((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)||0,timestamp:Date.now(),...metadata});// Mise à jour des statistiques\napiStats.errorCount++;if(apiStats.endpoints[endpoint]){apiStats.endpoints[endpoint].errorCount++;}// Mise à jour des données temporelles\nupdateTimeSeriesData();// Les erreurs API sont envoyées immédiatement\nsendBatchedMetrics();};/**\n * Enregistre l'utilisation d'un système de fallback\n * @param {string} endpoint - Endpoint de l'API\n * @param {string} fallbackType - Type de fallback (cache, données locales, etc.)\n * @param {Object} metadata - Métadonnées supplémentaires\n */const logFallbackUsage=function(endpoint,fallbackType){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();apiMetrics.push({type:'api_fallback',endpoint,fallbackType,timestamp:Date.now(),...metadata});// Mise à jour des statistiques\napiStats.fallbackCount++;// Mise à jour des données temporelles\nupdateTimeSeriesData();};/**\n * Enregistre un hit de cache\n * @param {string} endpoint - Endpoint de l'API\n * @param {number} savedTime - Temps économisé en ms\n */const logCacheHit=function(endpoint,savedTime){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!isInitialized)initialize();apiMetrics.push({type:'cache_hit',endpoint,savedTime,timestamp:Date.now(),...metadata});// Mise à jour des statistiques\napiStats.cacheHitCount++;if(apiStats.endpoints[endpoint]){apiStats.endpoints[endpoint].cacheHitCount++;}// Mise à jour des données temporelles\nupdateTimeSeriesData();};/**\n * Incrémente le compteur de retries\n * @param {string} endpoint - Endpoint de l'API\n * @param {number} retryCount - Nombre de tentatives\n */const incrementRetryCount=function(endpoint){let retryCount=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;apiStats.retryCount+=retryCount;apiMetrics.push({type:'api_retry',endpoint,retryCount,timestamp:Date.now()});// Mise à jour des données temporelles\nupdateTimeSeriesData();};/**\n * Suit un appel API et gère le debouncing pour éviter les appels redondants\n * @param {string} endpoint - Endpoint de l'API\n * @param {Object} parameters - Paramètres de l'appel\n * @param {Function} apiCall - Fonction d'appel API à exécuter\n * @returns {Promise<any>} Résultat de l'appel API\n */const trackApiCall=async(endpoint,parameters,apiCall)=>{if(!isInitialized)initialize();// Créer une clé unique pour cet appel (endpoint + paramètres sérialisés)\nconst callKey=`${endpoint}:${JSON.stringify(parameters)}`;// Vérifier si cet appel est déjà en cours (debouncing)\nif(apiDebounceMap.has(callKey)){return apiDebounceMap.get(callKey);}// Enregistrer le début de l'appel\nconst startTime=performance.now();// Créer une promesse pour cet appel et la stocker dans la map de debounce\nconst apiPromise=new Promise(async(resolve,reject)=>{try{// Exécuter l'appel API\nconst result=await apiCall();// Calculer la durée\nconst duration=performance.now()-startTime;// Suivre la performance\ntrackApiPerformance(endpoint,duration,{status:'success',parameterCount:Object.keys(parameters).length,responseSize:JSON.stringify(result).length,cached:result.cached||false});// Si le résultat provient du cache, enregistrer un hit de cache\nif(result.cached){logCacheHit(endpoint,duration,{result});}resolve(result);}catch(error){// Calculer la durée même en cas d'erreur\nconst duration=performance.now()-startTime;// Enregistrer l'erreur\nlogApiError(endpoint,error,{parameters,duration});reject(error);}finally{// Supprimer l'appel de la map de debounce après un court délai\n// pour permettre à d'autres appels identiques d'utiliser la même promesse\nsetTimeout(()=>{apiDebounceMap.delete(callKey);},100);}});// Stocker la promesse dans la map\napiDebounceMap.set(callKey,apiPromise);return apiPromise;};/**\n * Réinitialise les statistiques d'API\n */const resetApiStats=()=>{apiStats={callCount:0,errorCount:0,cacheHitCount:0,fallbackCount:0,retryCount:0,responseTimeTotal:0,longestResponseTime:0,endpoints:{},lastUpdated:Date.now(),timeSeriesData:{timestamps:[],responseTimes:[],errorRates:[],cacheHitRates:[]}};};/**\n * Récupère les statistiques d'API actuelles\n * @returns {Object} Statistiques d'API\n */const getApiStats=()=>{// Calculer les statistiques dérivées\nconst stats={...apiStats,avgResponseTime:apiStats.callCount>0?apiStats.responseTimeTotal/apiStats.callCount:0,errorRate:apiStats.callCount>0?apiStats.errorCount/apiStats.callCount*100:0,cacheHitRate:apiStats.callCount>0?apiStats.cacheHitCount/apiStats.callCount*100:0,retryRate:apiStats.callCount>0?apiStats.retryCount/apiStats.callCount*100:0};return stats;};/**\n * Met à jour les statistiques d'API pour les dashboards\n */const updateApiStats=async()=>{try{// Envoyer les statistiques au backend\nawait axios.post(API_METRICS_ENDPOINT,getApiStats());// Mettre à jour le timestamp de dernière mise à jour\napiStats.lastUpdated=Date.now();}catch(error){console.warn('Failed to update API stats:',error);}};/**\n * Met à jour les données temporelles pour les graphiques\n */const updateTimeSeriesData=()=>{const now=Date.now();// Limiter les points de données (garder les 100 derniers points)\nif(apiStats.timeSeriesData.timestamps.length>=100){apiStats.timeSeriesData.timestamps.shift();apiStats.timeSeriesData.responseTimes.shift();apiStats.timeSeriesData.errorRates.shift();apiStats.timeSeriesData.cacheHitRates.shift();}// Ajouter de nouveaux points de données\napiStats.timeSeriesData.timestamps.push(now);// Calculer les métriques\nconst avgResponseTime=apiStats.callCount>0?apiStats.responseTimeTotal/apiStats.callCount:0;const errorRate=apiStats.callCount>0?apiStats.errorCount/apiStats.callCount*100:0;const cacheHitRate=apiStats.callCount>0?apiStats.cacheHitCount/apiStats.callCount*100:0;// Ajouter les points de données\napiStats.timeSeriesData.responseTimes.push(avgResponseTime);apiStats.timeSeriesData.errorRates.push(errorRate);apiStats.timeSeriesData.cacheHitRates.push(cacheHitRate);};// Export du service\nconst monitoringService={initialize,trackComponentPerformance,trackComponentUnmount,trackBrowserPerformance,trackApiPerformance,trackError,trackUserInteraction,trackUserEngagement,trackGenericMetric,logApiError,logFallbackUsage,logCacheHit,incrementRetryCount,trackApiCall,getApiStats,resetApiStats,updateApiStats};// Auto-initialisation\ninitialize();export default monitoringService;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","METRICS_ENDPOINT","PERFORMANCE_ENDPOINT","ERROR_ENDPOINT","USER_TRACKING_ENDPOINT","API_METRICS_ENDPOINT","BATCH_INTERVAL","MAX_BATCH_SIZE","performanceMetrics","errorMetrics","userMetrics","apiMetrics","apiStats","callCount","errorCount","cacheHitCount","fallbackCount","retryCount","responseTimeTotal","longestResponseTime","endpoints","lastUpdated","Date","now","timeSeriesData","timestamps","responseTimes","errorRates","cacheHitRates","apiDebounceMap","Map","isInitialized","isSending","sessionId","initialize","Math","random","toString","substring","setInterval","sendBatchedMetrics","window","PerformanceObserver","perfObserver","list","getEntries","forEach","entry","includes","name","trackBrowserPerformance","value","observe","type","buffered","e","console","warn","addEventListener","event","trackError","message","filename","lineno","colno","stack","error","reason","trackGenericMetric","userAgent","navigator","screenSize","innerWidth","innerHeight","timestamp","length","metricsToSend","performance","slice","errors","userActivity","apiCalls","post","updateApiStats","storedMetrics","JSON","parse","localStorage","getItem","setItem","stringify","metrics","trackComponentPerformance","componentName","duration","metadata","arguments","undefined","push","component","trackComponentUnmount","sessionData","metricName","url","location","href","details","trackApiPerformance","endpoint","max","avgResponseTime","updateTimeSeriesData","errorType","errorDetails","trackUserInteraction","action","trackUserEngagement","feature","engagementData","data","logApiError","_error$response","errorMessage","errorCode","response","status","logFallbackUsage","fallbackType","logCacheHit","savedTime","incrementRetryCount","trackApiCall","parameters","apiCall","callKey","has","get","startTime","apiPromise","Promise","resolve","reject","result","parameterCount","Object","keys","responseSize","cached","setTimeout","delete","set","resetApiStats","getApiStats","stats","errorRate","cacheHitRate","retryRate","shift","monitoringService"],"sources":["C:/Users/busin/CascadeProjects/grand-est-cyclisme-website-final (1) VERSION FINAL/client/src/services/monitoringService.js"],"sourcesContent":["/**\n * Service de monitoring client\n * Collecte et envoie des métriques de performance, d'utilisation et d'erreurs\n * au backend pour analyse et affichage dans le tableau de bord de monitoring\n */\n\nimport axios from 'axios';\n\n// Configuration de base\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\nconst METRICS_ENDPOINT = `${API_URL}/monitoring/metrics`;\nconst PERFORMANCE_ENDPOINT = `${API_URL}/monitoring/performance`;\nconst ERROR_ENDPOINT = `${API_URL}/monitoring/errors`;\nconst USER_TRACKING_ENDPOINT = `${API_URL}/monitoring/user-tracking`;\nconst API_METRICS_ENDPOINT = `${API_URL}/monitoring/api-metrics`;\n\n// Configuration des intervalles d'envoi de données\nconst BATCH_INTERVAL = 30000; // 30 secondes entre chaque envoi de lot de métriques\nconst MAX_BATCH_SIZE = 50; // Nombre maximum de métriques par lot\n\n// Files d'attente pour les différents types de métriques\nlet performanceMetrics = [];\nlet errorMetrics = [];\nlet userMetrics = [];\nlet apiMetrics = [];\n\n// Statistiques d'API en temps réel (pour le dashboard)\nlet apiStats = {\n  callCount: 0,\n  errorCount: 0,\n  cacheHitCount: 0,\n  fallbackCount: 0,\n  retryCount: 0,\n  responseTimeTotal: 0,\n  longestResponseTime: 0,\n  endpoints: {},\n  lastUpdated: Date.now(),\n  // Données horodatées pour les graphiques\n  timeSeriesData: {\n    timestamps: [],\n    responseTimes: [],\n    errorRates: [],\n    cacheHitRates: []\n  }\n};\n\n// Map des debounces des appels API pour éviter les appels en double\nconst apiDebounceMap = new Map();\n\n// Indicateurs d'état\nlet isInitialized = false;\nlet isSending = false;\nlet sessionId = null;\n\n/**\n * Initialise le service de monitoring\n */\nconst initialize = () => {\n  if (isInitialized) return;\n  \n  // Générer un ID de session unique\n  sessionId = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\n  \n  // Configurer l'envoi périodique de métriques\n  setInterval(sendBatchedMetrics, BATCH_INTERVAL);\n  \n  // Écouter les événements de performance du navigateur\n  if (window.PerformanceObserver) {\n    try {\n      // Observer les mesures de performance Web Vitals\n      const perfObserver = new PerformanceObserver((list) => {\n        list.getEntries().forEach((entry) => {\n          if (['CLS', 'FID', 'LCP', 'FCP', 'TTFB'].includes(entry.name)) {\n            trackBrowserPerformance(entry.name, entry.value, entry);\n          }\n        });\n      });\n      \n      perfObserver.observe({ type: 'largest-contentful-paint', buffered: true });\n      perfObserver.observe({ type: 'first-input', buffered: true });\n      perfObserver.observe({ type: 'layout-shift', buffered: true });\n      perfObserver.observe({ type: 'paint', buffered: true });\n      \n    } catch (e) {\n      console.warn('PerformanceObserver not fully supported:', e);\n    }\n  }\n  \n  // Intercepter les erreurs non gérées\n  window.addEventListener('error', (event) => {\n    trackError('unhandled_exception', {\n      message: event.message,\n      filename: event.filename,\n      lineno: event.lineno,\n      colno: event.colno,\n      stack: event.error ? event.error.stack : null\n    });\n  });\n  \n  // Intercepter les rejets de promesses non gérés\n  window.addEventListener('unhandledrejection', (event) => {\n    trackError('unhandled_promise_rejection', {\n      reason: event.reason ? event.reason.toString() : 'Unknown reason',\n      stack: event.reason && event.reason.stack ? event.reason.stack : null\n    });\n  });\n  \n  // Marquer comme initialisé\n  isInitialized = true;\n  \n  // Envoyer une métrique d'initialisation\n  trackGenericMetric('monitoring_initialized', {\n    userAgent: navigator.userAgent,\n    screenSize: `${window.innerWidth}x${window.innerHeight}`,\n    timestamp: Date.now()\n  });\n};\n\n/**\n * Envoie les métriques accumulées au serveur\n */\nconst sendBatchedMetrics = async () => {\n  if (isSending || \n      (performanceMetrics.length === 0 && \n       errorMetrics.length === 0 && \n       userMetrics.length === 0 && \n       apiMetrics.length === 0)) {\n    return;\n  }\n  \n  isSending = true;\n  \n  try {\n    // Collecter les métriques actuelles et vider les files d'attente\n    const metricsToSend = {\n      sessionId,\n      timestamp: Date.now(),\n      performance: [...performanceMetrics].slice(0, MAX_BATCH_SIZE),\n      errors: [...errorMetrics].slice(0, MAX_BATCH_SIZE),\n      userActivity: [...userMetrics].slice(0, MAX_BATCH_SIZE),\n      apiCalls: [...apiMetrics].slice(0, MAX_BATCH_SIZE)\n    };\n    \n    // Vider les files d'attente des métriques envoyées\n    performanceMetrics = performanceMetrics.slice(MAX_BATCH_SIZE);\n    errorMetrics = errorMetrics.slice(MAX_BATCH_SIZE);\n    userMetrics = userMetrics.slice(MAX_BATCH_SIZE);\n    apiMetrics = apiMetrics.slice(MAX_BATCH_SIZE);\n    \n    // Envoyer les métriques au backend\n    await axios.post(METRICS_ENDPOINT, metricsToSend);\n    \n    // Mettre à jour les statistiques d'API pour le dashboard\n    updateApiStats();\n    \n  } catch (error) {\n    // En cas d'erreur, stocker localement pour réessayer plus tard\n    console.warn('Failed to send metrics to server:', error);\n    \n    // Stocker jusqu'à 1000 métriques localement en cas de problème de connexion\n    const storedMetrics = JSON.parse(localStorage.getItem('pendingMetrics') || '[]');\n    if (storedMetrics.length < 1000) {\n      localStorage.setItem('pendingMetrics', JSON.stringify([\n        ...storedMetrics,\n        {\n          timestamp: Date.now(),\n          metrics: metricsToSend\n        }\n      ]));\n    }\n  } finally {\n    isSending = false;\n  }\n};\n\n/**\n * Suivi des performances d'un composant (temps de rendu, chargement, etc.)\n * @param {string} componentName - Nom du composant\n * @param {number} duration - Durée en millisecondes\n * @param {Object} metadata - Métadonnées supplémentaires\n */\nconst trackComponentPerformance = (componentName, duration, metadata = {}) => {\n  if (!isInitialized) initialize();\n  \n  performanceMetrics.push({\n    type: 'component_performance',\n    component: componentName,\n    duration,\n    timestamp: Date.now(),\n    ...metadata\n  });\n  \n  // Si des métriques clés sont lentes, envoyer immédiatement\n  if (duration > 1000 && componentName.includes('Calculator')) {\n    sendBatchedMetrics();\n  }\n};\n\n/**\n * Suivi du démontage d'un composant (fin de session d'utilisation)\n * @param {string} componentName - Nom du composant\n * @param {Object} sessionData - Données de la session (durée, actions, etc.)\n */\nconst trackComponentUnmount = (componentName, sessionData = {}) => {\n  if (!isInitialized) initialize();\n  \n  performanceMetrics.push({\n    type: 'component_unmount',\n    component: componentName,\n    timestamp: Date.now(),\n    ...sessionData\n  });\n};\n\n/**\n * Suivi des performances du navigateur (Web Vitals)\n * @param {string} metricName - Nom de la métrique (CLS, FID, LCP, etc.)\n * @param {number} value - Valeur de la métrique\n * @param {Object} entry - Entrée de performance originale\n */\nconst trackBrowserPerformance = (metricName, value, entry = {}) => {\n  if (!isInitialized) initialize();\n  \n  performanceMetrics.push({\n    type: 'browser_performance',\n    metricName,\n    value,\n    timestamp: Date.now(),\n    url: window.location.href,\n    details: entry\n  });\n};\n\n/**\n * Suivi des performances d'API\n * @param {string} endpoint - Endpoint de l'API appelé\n * @param {number} duration - Durée en millisecondes\n * @param {Object} metadata - Métadonnées (statut, taille de la réponse, etc.)\n */\nconst trackApiPerformance = (endpoint, duration, metadata = {}) => {\n  if (!isInitialized) initialize();\n  \n  apiMetrics.push({\n    type: 'api_performance',\n    endpoint,\n    duration,\n    timestamp: Date.now(),\n    ...metadata\n  });\n  \n  // Mise à jour des statistiques en temps réel\n  apiStats.callCount++;\n  apiStats.responseTimeTotal += duration;\n  apiStats.longestResponseTime = Math.max(apiStats.longestResponseTime, duration);\n  \n  // Mise à jour des données par endpoint\n  if (!apiStats.endpoints[endpoint]) {\n    apiStats.endpoints[endpoint] = {\n      callCount: 0,\n      errorCount: 0,\n      cacheHitCount: 0,\n      responseTimeTotal: 0,\n      avgResponseTime: 0\n    };\n  }\n  \n  apiStats.endpoints[endpoint].callCount++;\n  apiStats.endpoints[endpoint].responseTimeTotal += duration;\n  apiStats.endpoints[endpoint].avgResponseTime = \n    apiStats.endpoints[endpoint].responseTimeTotal / apiStats.endpoints[endpoint].callCount;\n  \n  // Mise à jour des données temporelles pour les graphiques\n  updateTimeSeriesData();\n  \n  // Si un appel API est particulièrement lent, signaler immédiatement\n  if (duration > 3000) {\n    sendBatchedMetrics();\n  }\n};\n\n/**\n * Suivi des erreurs\n * @param {string} errorType - Type d'erreur\n * @param {Object} errorDetails - Détails de l'erreur\n */\nconst trackError = (errorType, errorDetails = {}) => {\n  if (!isInitialized) initialize();\n  \n  errorMetrics.push({\n    type: 'error',\n    errorType,\n    timestamp: Date.now(),\n    url: window.location.href,\n    ...errorDetails\n  });\n  \n  // Les erreurs sont envoyées immédiatement\n  sendBatchedMetrics();\n};\n\n/**\n * Suivi des interactions utilisateur\n * @param {string} componentName - Nom du composant\n * @param {string} action - Action effectuée\n * @param {Object} metadata - Métadonnées supplémentaires\n */\nconst trackUserInteraction = (componentName, action, metadata = {}) => {\n  if (!isInitialized) initialize();\n  \n  userMetrics.push({\n    type: 'user_interaction',\n    component: componentName,\n    action,\n    timestamp: Date.now(),\n    url: window.location.href,\n    ...metadata\n  });\n};\n\n/**\n * Suivi de l'engagement utilisateur sur la durée\n * @param {string} feature - Fonctionnalité utilisée\n * @param {Object} engagementData - Données d'engagement\n */\nconst trackUserEngagement = (feature, engagementData = {}) => {\n  if (!isInitialized) initialize();\n  \n  userMetrics.push({\n    type: 'user_engagement',\n    feature,\n    timestamp: Date.now(),\n    url: window.location.href,\n    ...engagementData\n  });\n};\n\n/**\n * Suivi d'une métrique générique\n * @param {string} metricName - Nom de la métrique\n * @param {Object} data - Données associées\n */\nconst trackGenericMetric = (metricName, data = {}) => {\n  if (!isInitialized) initialize();\n  \n  performanceMetrics.push({\n    type: 'generic',\n    metricName,\n    timestamp: Date.now(),\n    ...data\n  });\n};\n\n/**\n * Enregistre une erreur d'API\n * @param {string} endpoint - Endpoint de l'API\n * @param {Object} error - Objet d'erreur\n * @param {Object} metadata - Métadonnées supplémentaires\n */\nconst logApiError = (endpoint, error, metadata = {}) => {\n  if (!isInitialized) initialize();\n  \n  errorMetrics.push({\n    type: 'api_error',\n    endpoint,\n    errorMessage: error.message || 'Unknown error',\n    errorCode: error.response?.status || 0,\n    timestamp: Date.now(),\n    ...metadata\n  });\n  \n  // Mise à jour des statistiques\n  apiStats.errorCount++;\n  \n  if (apiStats.endpoints[endpoint]) {\n    apiStats.endpoints[endpoint].errorCount++;\n  }\n  \n  // Mise à jour des données temporelles\n  updateTimeSeriesData();\n  \n  // Les erreurs API sont envoyées immédiatement\n  sendBatchedMetrics();\n};\n\n/**\n * Enregistre l'utilisation d'un système de fallback\n * @param {string} endpoint - Endpoint de l'API\n * @param {string} fallbackType - Type de fallback (cache, données locales, etc.)\n * @param {Object} metadata - Métadonnées supplémentaires\n */\nconst logFallbackUsage = (endpoint, fallbackType, metadata = {}) => {\n  if (!isInitialized) initialize();\n  \n  apiMetrics.push({\n    type: 'api_fallback',\n    endpoint,\n    fallbackType,\n    timestamp: Date.now(),\n    ...metadata\n  });\n  \n  // Mise à jour des statistiques\n  apiStats.fallbackCount++;\n  \n  // Mise à jour des données temporelles\n  updateTimeSeriesData();\n};\n\n/**\n * Enregistre un hit de cache\n * @param {string} endpoint - Endpoint de l'API\n * @param {number} savedTime - Temps économisé en ms\n */\nconst logCacheHit = (endpoint, savedTime, metadata = {}) => {\n  if (!isInitialized) initialize();\n  \n  apiMetrics.push({\n    type: 'cache_hit',\n    endpoint,\n    savedTime,\n    timestamp: Date.now(),\n    ...metadata\n  });\n  \n  // Mise à jour des statistiques\n  apiStats.cacheHitCount++;\n  \n  if (apiStats.endpoints[endpoint]) {\n    apiStats.endpoints[endpoint].cacheHitCount++;\n  }\n  \n  // Mise à jour des données temporelles\n  updateTimeSeriesData();\n};\n\n/**\n * Incrémente le compteur de retries\n * @param {string} endpoint - Endpoint de l'API\n * @param {number} retryCount - Nombre de tentatives\n */\nconst incrementRetryCount = (endpoint, retryCount = 1) => {\n  apiStats.retryCount += retryCount;\n  \n  apiMetrics.push({\n    type: 'api_retry',\n    endpoint,\n    retryCount,\n    timestamp: Date.now()\n  });\n  \n  // Mise à jour des données temporelles\n  updateTimeSeriesData();\n};\n\n/**\n * Suit un appel API et gère le debouncing pour éviter les appels redondants\n * @param {string} endpoint - Endpoint de l'API\n * @param {Object} parameters - Paramètres de l'appel\n * @param {Function} apiCall - Fonction d'appel API à exécuter\n * @returns {Promise<any>} Résultat de l'appel API\n */\nconst trackApiCall = async (endpoint, parameters, apiCall) => {\n  if (!isInitialized) initialize();\n  \n  // Créer une clé unique pour cet appel (endpoint + paramètres sérialisés)\n  const callKey = `${endpoint}:${JSON.stringify(parameters)}`;\n  \n  // Vérifier si cet appel est déjà en cours (debouncing)\n  if (apiDebounceMap.has(callKey)) {\n    return apiDebounceMap.get(callKey);\n  }\n  \n  // Enregistrer le début de l'appel\n  const startTime = performance.now();\n  \n  // Créer une promesse pour cet appel et la stocker dans la map de debounce\n  const apiPromise = new Promise(async (resolve, reject) => {\n    try {\n      // Exécuter l'appel API\n      const result = await apiCall();\n      \n      // Calculer la durée\n      const duration = performance.now() - startTime;\n      \n      // Suivre la performance\n      trackApiPerformance(endpoint, duration, {\n        status: 'success',\n        parameterCount: Object.keys(parameters).length,\n        responseSize: JSON.stringify(result).length,\n        cached: result.cached || false\n      });\n      \n      // Si le résultat provient du cache, enregistrer un hit de cache\n      if (result.cached) {\n        logCacheHit(endpoint, duration, { result });\n      }\n      \n      resolve(result);\n    } catch (error) {\n      // Calculer la durée même en cas d'erreur\n      const duration = performance.now() - startTime;\n      \n      // Enregistrer l'erreur\n      logApiError(endpoint, error, {\n        parameters,\n        duration\n      });\n      \n      reject(error);\n    } finally {\n      // Supprimer l'appel de la map de debounce après un court délai\n      // pour permettre à d'autres appels identiques d'utiliser la même promesse\n      setTimeout(() => {\n        apiDebounceMap.delete(callKey);\n      }, 100);\n    }\n  });\n  \n  // Stocker la promesse dans la map\n  apiDebounceMap.set(callKey, apiPromise);\n  \n  return apiPromise;\n};\n\n/**\n * Réinitialise les statistiques d'API\n */\nconst resetApiStats = () => {\n  apiStats = {\n    callCount: 0,\n    errorCount: 0,\n    cacheHitCount: 0,\n    fallbackCount: 0,\n    retryCount: 0,\n    responseTimeTotal: 0,\n    longestResponseTime: 0,\n    endpoints: {},\n    lastUpdated: Date.now(),\n    timeSeriesData: {\n      timestamps: [],\n      responseTimes: [],\n      errorRates: [],\n      cacheHitRates: []\n    }\n  };\n};\n\n/**\n * Récupère les statistiques d'API actuelles\n * @returns {Object} Statistiques d'API\n */\nconst getApiStats = () => {\n  // Calculer les statistiques dérivées\n  const stats = {\n    ...apiStats,\n    avgResponseTime: apiStats.callCount > 0 \n      ? apiStats.responseTimeTotal / apiStats.callCount \n      : 0,\n    errorRate: apiStats.callCount > 0 \n      ? (apiStats.errorCount / apiStats.callCount) * 100 \n      : 0,\n    cacheHitRate: apiStats.callCount > 0 \n      ? (apiStats.cacheHitCount / apiStats.callCount) * 100 \n      : 0,\n    retryRate: apiStats.callCount > 0 \n      ? (apiStats.retryCount / apiStats.callCount) * 100 \n      : 0\n  };\n  \n  return stats;\n};\n\n/**\n * Met à jour les statistiques d'API pour les dashboards\n */\nconst updateApiStats = async () => {\n  try {\n    // Envoyer les statistiques au backend\n    await axios.post(API_METRICS_ENDPOINT, getApiStats());\n    \n    // Mettre à jour le timestamp de dernière mise à jour\n    apiStats.lastUpdated = Date.now();\n  } catch (error) {\n    console.warn('Failed to update API stats:', error);\n  }\n};\n\n/**\n * Met à jour les données temporelles pour les graphiques\n */\nconst updateTimeSeriesData = () => {\n  const now = Date.now();\n  \n  // Limiter les points de données (garder les 100 derniers points)\n  if (apiStats.timeSeriesData.timestamps.length >= 100) {\n    apiStats.timeSeriesData.timestamps.shift();\n    apiStats.timeSeriesData.responseTimes.shift();\n    apiStats.timeSeriesData.errorRates.shift();\n    apiStats.timeSeriesData.cacheHitRates.shift();\n  }\n  \n  // Ajouter de nouveaux points de données\n  apiStats.timeSeriesData.timestamps.push(now);\n  \n  // Calculer les métriques\n  const avgResponseTime = apiStats.callCount > 0 \n    ? apiStats.responseTimeTotal / apiStats.callCount \n    : 0;\n    \n  const errorRate = apiStats.callCount > 0 \n    ? (apiStats.errorCount / apiStats.callCount) * 100 \n    : 0;\n    \n  const cacheHitRate = apiStats.callCount > 0 \n    ? (apiStats.cacheHitCount / apiStats.callCount) * 100 \n    : 0;\n  \n  // Ajouter les points de données\n  apiStats.timeSeriesData.responseTimes.push(avgResponseTime);\n  apiStats.timeSeriesData.errorRates.push(errorRate);\n  apiStats.timeSeriesData.cacheHitRates.push(cacheHitRate);\n};\n\n// Export du service\nconst monitoringService = {\n  initialize,\n  trackComponentPerformance,\n  trackComponentUnmount,\n  trackBrowserPerformance,\n  trackApiPerformance,\n  trackError,\n  trackUserInteraction,\n  trackUserEngagement,\n  trackGenericMetric,\n  logApiError,\n  logFallbackUsage,\n  logCacheHit,\n  incrementRetryCount,\n  trackApiCall,\n  getApiStats,\n  resetApiStats,\n  updateApiStats\n};\n\n// Auto-initialisation\ninitialize();\n\nexport default monitoringService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}