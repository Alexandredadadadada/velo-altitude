{"ast":null,"code":"/**\n * Client d'authentification amélioré\n * Gère la rotation des tokens JWT, les périodes de grâce et la révocation sélective des tokens\n */import{jwtDecode}from'jwt-decode';import clientFingerprintService from'./clientFingerprintService';export class AuthError extends Error{constructor(message,code){super(message);this.name='AuthError';this.code=code;}}export class LocalStorageTokenStore{constructor(){let prefix=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'auth_';this.prefix=prefix;}async getAccessToken(){return localStorage.getItem(`${this.prefix}access_token`);}async getRefreshToken(){return localStorage.getItem(`${this.prefix}refresh_token`);}async setTokens(accessToken,refreshToken){localStorage.setItem(`${this.prefix}access_token`,accessToken);localStorage.setItem(`${this.prefix}refresh_token`,refreshToken);}async clearTokens(){localStorage.removeItem(`${this.prefix}access_token`);localStorage.removeItem(`${this.prefix}refresh_token`);}}export class EnhancedAuthClient{constructor(){let options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.baseUrl=options.baseUrl||'/api/auth';this.tokenStorage=options.tokenStorage||new LocalStorageTokenStore();this.refreshThreshold=options.refreshThreshold||300;// 5 minutes in seconds\nthis.graceEnabled=options.graceEnabled!==false;// Enable grace period by default\nthis.onSessionExpired=options.onSessionExpired||(()=>{window.dispatchEvent(new CustomEvent('auth:session-expired'));});this.onTokenRevoked=options.onTokenRevoked||(()=>{window.dispatchEvent(new CustomEvent('auth:token-revoked'));});// Setup token refresh interval\nthis.refreshInterval=setInterval(()=>{this.checkAndRefreshToken();},(options.refreshCheckInterval||60)*1000);// Check every minute by default\n}/**\n   * Connecte l'utilisateur\n   * @param {Object} credentials Identifiants de connexion (email, password)\n   * @returns {Promise<Object>} Informations utilisateur\n   */async login(credentials){try{// Ajouter l'empreinte client aux données de connexion\nconst clientFingerprint=clientFingerprintService.getAuthFingerprint();const loginData={...credentials,clientFingerprint};const response=await fetch(`${this.baseUrl}/login`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(loginData)});if(!response.ok){const error=await response.json();throw new AuthError(error.message,error.code);}const data=await response.json();await this.tokenStorage.setTokens(data.accessToken,data.refreshToken);return data.user;}catch(error){console.error('Login failed:',error);throw error;}}/**\n   * Déconnecte l'utilisateur\n   * @param {boolean} revokeAll Si true, révoque tous les tokens de l'utilisateur sur tous les appareils\n   * @returns {Promise<void>}\n   */async logout(){let revokeAll=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;try{const refreshToken=await this.tokenStorage.getRefreshToken();if(refreshToken){// Révoquer le token sur le serveur\nawait fetch(`${this.baseUrl}/logout`,{method:'POST',headers:{'Content-Type':'application/json','Authorization':`Bearer ${await this.tokenStorage.getAccessToken()}`},body:JSON.stringify({refreshToken,revokeAll,clientFingerprint:clientFingerprintService.getFingerprintId()})});}}catch(error){console.warn('Error during logout:',error);}finally{// Supprimer les tokens localement indépendamment de la réponse du serveur\nawait this.tokenStorage.clearTokens();clearInterval(this.refreshInterval);}}/**\n   * Fournit une fonction fetch authentifiée\n   * @returns {Promise<Function>} Une fonction fetch avec authentification\n   */async getAuthenticatedFetch(){var _this=this;const accessToken=await this.tokenStorage.getAccessToken();if(!accessToken){throw new AuthError('No access token available','no_token');}return async function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Cloner les options pour éviter de modifier l'original\nconst fetchOptions={...options};// Ajouter l'en-tête d'autorisation\nfetchOptions.headers={...fetchOptions.headers,'Authorization':`Bearer ${accessToken}`};// Ajouter l'empreinte client aux en-têtes\nconst fingerprint=clientFingerprintService.getFingerprintId();if(fingerprint){fetchOptions.headers['X-Client-ID']=fingerprint;}try{const response=await fetch(url,fetchOptions);// Gérer les erreurs d'authentification\nif(response.status===401||response.status===403){let errorData;try{errorData=await response.json();}catch(e){errorData={message:'Authentication error',code:'auth_error'};}// Si le token est expiré mais dans la période de grâce, essayer de le rafraîchir\nif(errorData.code==='token_expired'&&_this.graceEnabled){try{const newToken=await _this.refreshToken();if(newToken){// Réessayer avec le nouveau token\nfetchOptions.headers['Authorization']=`Bearer ${newToken}`;return fetch(url,fetchOptions);}}catch(refreshError){console.error('Failed to refresh token during grace period:',refreshError);}}throw new AuthError(errorData.message,errorData.code);}return response;}catch(error){if(error instanceof AuthError){// Gérer les erreurs d'authentification spécifiques\nif(error.code==='token_revoked'){await _this.tokenStorage.clearTokens();_this.onTokenRevoked();}else if(error.code==='session_expired'||error.code==='invalid_token'){await _this.tokenStorage.clearTokens();_this.onSessionExpired();}}throw error;}};}/**\n   * Rafraîchit le token d'accès\n   * @returns {Promise<string>} Nouveau token d'accès\n   */async refreshToken(){try{const refreshToken=await this.tokenStorage.getRefreshToken();if(!refreshToken){throw new AuthError('No refresh token available','no_refresh_token');}// Inclure l'empreinte client dans la demande de rafraîchissement\nconst fingerprint=clientFingerprintService.getAuthFingerprint();const response=await fetch(`${this.baseUrl}/refresh`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({refreshToken,clientFingerprint:fingerprint})});if(!response.ok){const error=await response.json();throw new AuthError(error.message,error.code);}const data=await response.json();await this.tokenStorage.setTokens(data.accessToken,data.refreshToken);return data.accessToken;}catch(error){console.error('Token refresh failed:',error);if(error.code==='invalid_refresh_token'||error.code==='refresh_token_expired'){await this.tokenStorage.clearTokens();this.onSessionExpired();}throw error;}}/**\n   * Vérifie si le token est sur le point d'expirer et le rafraîchit si nécessaire\n   * @returns {Promise<void>}\n   */async checkAndRefreshToken(){try{const accessToken=await this.tokenStorage.getAccessToken();if(!accessToken)return;// Décoder le token sans vérification pour vérifier l'expiration\nconst payload=this._decodeToken(accessToken);if(!payload||!payload.exp)return;const now=Math.floor(Date.now()/1000);const timeUntilExpiry=payload.exp-now;// Rafraîchir si le token est sur le point d'expirer\nif(timeUntilExpiry<this.refreshThreshold){await this.refreshToken();}}catch(error){console.warn('Error checking token expiration:',error);}}/**\n   * Décode un token JWT sans vérification de signature\n   * @private\n   * @param {string} token Token JWT\n   * @returns {Object|null} Contenu décodé du token\n   */_decodeToken(token){try{return jwtDecode(token);}catch(error){console.error('Error decoding token:',error);return null;}}/**\n   * Vérifie si l'utilisateur est authentifié\n   * @returns {Promise<boolean>} Statut d'authentification\n   */async isAuthenticated(){const accessToken=await this.tokenStorage.getAccessToken();if(!accessToken)return false;const payload=this._decodeToken(accessToken);if(!payload||!payload.exp)return false;const now=Math.floor(Date.now()/1000);return payload.exp>now;}/**\n   * Récupère les informations utilisateur du token\n   * @returns {Promise<Object|null>} Informations utilisateur\n   */async getUserInfo(){const accessToken=await this.tokenStorage.getAccessToken();if(!accessToken)return null;const payload=this._decodeToken(accessToken);return payload?payload.user:null;}/**\n   * Nettoie les ressources utilisées par le client\n   */dispose(){clearInterval(this.refreshInterval);}}// Export d'une instance singleton avec les paramètres par défaut\nconst enhancedAuthClient=new EnhancedAuthClient();export default enhancedAuthClient;","map":{"version":3,"names":["jwtDecode","clientFingerprintService","AuthError","Error","constructor","message","code","name","LocalStorageTokenStore","prefix","arguments","length","undefined","getAccessToken","localStorage","getItem","getRefreshToken","setTokens","accessToken","refreshToken","setItem","clearTokens","removeItem","EnhancedAuthClient","options","baseUrl","tokenStorage","refreshThreshold","graceEnabled","onSessionExpired","window","dispatchEvent","CustomEvent","onTokenRevoked","refreshInterval","setInterval","checkAndRefreshToken","refreshCheckInterval","login","credentials","clientFingerprint","getAuthFingerprint","loginData","response","fetch","method","headers","body","JSON","stringify","ok","error","json","data","user","console","logout","revokeAll","getFingerprintId","warn","clearInterval","getAuthenticatedFetch","_this","url","fetchOptions","fingerprint","status","errorData","e","newToken","refreshError","payload","_decodeToken","exp","now","Math","floor","Date","timeUntilExpiry","token","isAuthenticated","getUserInfo","dispose","enhancedAuthClient"],"sources":["C:/Users/busin/CascadeProjects/grand-est-cyclisme-website-final (1) VERSION FINAL/client/src/services/enhancedAuthClient.js"],"sourcesContent":["/**\n * Client d'authentification amélioré\n * Gère la rotation des tokens JWT, les périodes de grâce et la révocation sélective des tokens\n */\n\nimport { jwtDecode } from 'jwt-decode';\nimport clientFingerprintService from './clientFingerprintService';\n\nexport class AuthError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AuthError';\n    this.code = code;\n  }\n}\n\nexport class LocalStorageTokenStore {\n  constructor(prefix = 'auth_') {\n    this.prefix = prefix;\n  }\n\n  async getAccessToken() {\n    return localStorage.getItem(`${this.prefix}access_token`);\n  }\n\n  async getRefreshToken() {\n    return localStorage.getItem(`${this.prefix}refresh_token`);\n  }\n\n  async setTokens(accessToken, refreshToken) {\n    localStorage.setItem(`${this.prefix}access_token`, accessToken);\n    localStorage.setItem(`${this.prefix}refresh_token`, refreshToken);\n  }\n\n  async clearTokens() {\n    localStorage.removeItem(`${this.prefix}access_token`);\n    localStorage.removeItem(`${this.prefix}refresh_token`);\n  }\n}\n\nexport class EnhancedAuthClient {\n  constructor(options = {}) {\n    this.baseUrl = options.baseUrl || '/api/auth';\n    this.tokenStorage = options.tokenStorage || new LocalStorageTokenStore();\n    this.refreshThreshold = options.refreshThreshold || 300; // 5 minutes in seconds\n    this.graceEnabled = options.graceEnabled !== false; // Enable grace period by default\n    this.onSessionExpired = options.onSessionExpired || (() => {\n      window.dispatchEvent(new CustomEvent('auth:session-expired'));\n    });\n    this.onTokenRevoked = options.onTokenRevoked || (() => {\n      window.dispatchEvent(new CustomEvent('auth:token-revoked'));\n    });\n    \n    // Setup token refresh interval\n    this.refreshInterval = setInterval(() => {\n      this.checkAndRefreshToken();\n    }, (options.refreshCheckInterval || 60) * 1000); // Check every minute by default\n  }\n\n  /**\n   * Connecte l'utilisateur\n   * @param {Object} credentials Identifiants de connexion (email, password)\n   * @returns {Promise<Object>} Informations utilisateur\n   */\n  async login(credentials) {\n    try {\n      // Ajouter l'empreinte client aux données de connexion\n      const clientFingerprint = clientFingerprintService.getAuthFingerprint();\n      const loginData = {\n        ...credentials,\n        clientFingerprint\n      };\n\n      const response = await fetch(`${this.baseUrl}/login`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(loginData)\n      });\n      \n      if (!response.ok) {\n        const error = await response.json();\n        throw new AuthError(error.message, error.code);\n      }\n      \n      const data = await response.json();\n      await this.tokenStorage.setTokens(data.accessToken, data.refreshToken);\n      return data.user;\n    } catch (error) {\n      console.error('Login failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Déconnecte l'utilisateur\n   * @param {boolean} revokeAll Si true, révoque tous les tokens de l'utilisateur sur tous les appareils\n   * @returns {Promise<void>}\n   */\n  async logout(revokeAll = false) {\n    try {\n      const refreshToken = await this.tokenStorage.getRefreshToken();\n      if (refreshToken) {\n        // Révoquer le token sur le serveur\n        await fetch(`${this.baseUrl}/logout`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${await this.tokenStorage.getAccessToken()}`\n          },\n          body: JSON.stringify({ \n            refreshToken,\n            revokeAll,\n            clientFingerprint: clientFingerprintService.getFingerprintId()\n          })\n        });\n      }\n    } catch (error) {\n      console.warn('Error during logout:', error);\n    } finally {\n      // Supprimer les tokens localement indépendamment de la réponse du serveur\n      await this.tokenStorage.clearTokens();\n      clearInterval(this.refreshInterval);\n    }\n  }\n\n  /**\n   * Fournit une fonction fetch authentifiée\n   * @returns {Promise<Function>} Une fonction fetch avec authentification\n   */\n  async getAuthenticatedFetch() {\n    const accessToken = await this.tokenStorage.getAccessToken();\n    if (!accessToken) {\n      throw new AuthError('No access token available', 'no_token');\n    }\n    \n    return async (url, options = {}) => {\n      // Cloner les options pour éviter de modifier l'original\n      const fetchOptions = { ...options };\n      \n      // Ajouter l'en-tête d'autorisation\n      fetchOptions.headers = {\n        ...fetchOptions.headers,\n        'Authorization': `Bearer ${accessToken}`\n      };\n      \n      // Ajouter l'empreinte client aux en-têtes\n      const fingerprint = clientFingerprintService.getFingerprintId();\n      if (fingerprint) {\n        fetchOptions.headers['X-Client-ID'] = fingerprint;\n      }\n      \n      try {\n        const response = await fetch(url, fetchOptions);\n        \n        // Gérer les erreurs d'authentification\n        if (response.status === 401 || response.status === 403) {\n          let errorData;\n          try {\n            errorData = await response.json();\n          } catch (e) {\n            errorData = { message: 'Authentication error', code: 'auth_error' };\n          }\n          \n          // Si le token est expiré mais dans la période de grâce, essayer de le rafraîchir\n          if (errorData.code === 'token_expired' && this.graceEnabled) {\n            try {\n              const newToken = await this.refreshToken();\n              if (newToken) {\n                // Réessayer avec le nouveau token\n                fetchOptions.headers['Authorization'] = `Bearer ${newToken}`;\n                return fetch(url, fetchOptions);\n              }\n            } catch (refreshError) {\n              console.error('Failed to refresh token during grace period:', refreshError);\n            }\n          }\n          \n          throw new AuthError(errorData.message, errorData.code);\n        }\n        \n        return response;\n      } catch (error) {\n        if (error instanceof AuthError) {\n          // Gérer les erreurs d'authentification spécifiques\n          if (error.code === 'token_revoked') {\n            await this.tokenStorage.clearTokens();\n            this.onTokenRevoked();\n          } else if (error.code === 'session_expired' || error.code === 'invalid_token') {\n            await this.tokenStorage.clearTokens();\n            this.onSessionExpired();\n          }\n        }\n        throw error;\n      }\n    };\n  }\n\n  /**\n   * Rafraîchit le token d'accès\n   * @returns {Promise<string>} Nouveau token d'accès\n   */\n  async refreshToken() {\n    try {\n      const refreshToken = await this.tokenStorage.getRefreshToken();\n      if (!refreshToken) {\n        throw new AuthError('No refresh token available', 'no_refresh_token');\n      }\n      \n      // Inclure l'empreinte client dans la demande de rafraîchissement\n      const fingerprint = clientFingerprintService.getAuthFingerprint();\n      \n      const response = await fetch(`${this.baseUrl}/refresh`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          refreshToken,\n          clientFingerprint: fingerprint\n        })\n      });\n      \n      if (!response.ok) {\n        const error = await response.json();\n        throw new AuthError(error.message, error.code);\n      }\n      \n      const data = await response.json();\n      await this.tokenStorage.setTokens(data.accessToken, data.refreshToken);\n      return data.accessToken;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      if (error.code === 'invalid_refresh_token' || error.code === 'refresh_token_expired') {\n        await this.tokenStorage.clearTokens();\n        this.onSessionExpired();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Vérifie si le token est sur le point d'expirer et le rafraîchit si nécessaire\n   * @returns {Promise<void>}\n   */\n  async checkAndRefreshToken() {\n    try {\n      const accessToken = await this.tokenStorage.getAccessToken();\n      if (!accessToken) return;\n      \n      // Décoder le token sans vérification pour vérifier l'expiration\n      const payload = this._decodeToken(accessToken);\n      if (!payload || !payload.exp) return;\n      \n      const now = Math.floor(Date.now() / 1000);\n      const timeUntilExpiry = payload.exp - now;\n      \n      // Rafraîchir si le token est sur le point d'expirer\n      if (timeUntilExpiry < this.refreshThreshold) {\n        await this.refreshToken();\n      }\n    } catch (error) {\n      console.warn('Error checking token expiration:', error);\n    }\n  }\n\n  /**\n   * Décode un token JWT sans vérification de signature\n   * @private\n   * @param {string} token Token JWT\n   * @returns {Object|null} Contenu décodé du token\n   */\n  _decodeToken(token) {\n    try {\n      return jwtDecode(token);\n    } catch (error) {\n      console.error('Error decoding token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Vérifie si l'utilisateur est authentifié\n   * @returns {Promise<boolean>} Statut d'authentification\n   */\n  async isAuthenticated() {\n    const accessToken = await this.tokenStorage.getAccessToken();\n    if (!accessToken) return false;\n    \n    const payload = this._decodeToken(accessToken);\n    if (!payload || !payload.exp) return false;\n    \n    const now = Math.floor(Date.now() / 1000);\n    return payload.exp > now;\n  }\n\n  /**\n   * Récupère les informations utilisateur du token\n   * @returns {Promise<Object|null>} Informations utilisateur\n   */\n  async getUserInfo() {\n    const accessToken = await this.tokenStorage.getAccessToken();\n    if (!accessToken) return null;\n    \n    const payload = this._decodeToken(accessToken);\n    return payload ? payload.user : null;\n  }\n\n  /**\n   * Nettoie les ressources utilisées par le client\n   */\n  dispose() {\n    clearInterval(this.refreshInterval);\n  }\n}\n\n// Export d'une instance singleton avec les paramètres par défaut\nconst enhancedAuthClient = new EnhancedAuthClient();\nexport default enhancedAuthClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}