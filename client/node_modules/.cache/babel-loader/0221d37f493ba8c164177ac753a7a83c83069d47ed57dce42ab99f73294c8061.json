{"ast":null,"code":"/**\n * Service de configuration centrale pour les API\n * Ce fichier configure axios pour toutes les requêtes API\n */import axios from'axios';// Récupérer l'URL de base depuis les variables d'environnement\nconst API_URL=process.env.REACT_APP_API_URL||'http://localhost:3000';const USE_MOCK_DATA=process.env.REACT_APP_USE_MOCK_DATA==='true';// Création d'une instance axios avec la configuration de base\nconst api=axios.create({baseURL:API_URL,headers:{'Content-Type':'application/json'},// Ajouter un timeout par défaut pour éviter les requêtes bloquées indéfiniment\ntimeout:30000,// 30 secondes\n// Activer les credentials pour les cookies\nwithCredentials:true});// Intercepteur pour ajouter le token d'authentification JWT à chaque requête\napi.interceptors.request.use(config=>{// Récupérer le token depuis les cookies ou localStorage\n// Note: Les cookies httpOnly ne sont pas accessibles via JavaScript\n// mais le token peut être stocké dans localStorage pour la compatibilité\nconst token=localStorage.getItem('authToken');if(token){config.headers.Authorization=`Bearer ${token}`;}// Ajouter un timestamp pour éviter la mise en cache des requêtes GET\nif(config.method==='get'){config.params={...config.params,_t:Date.now()};}return config;},error=>Promise.reject(error));// Intercepteur pour gérer les réponses et les erreurs\napi.interceptors.response.use(response=>{// Vérifier si la réponse contient un nouveau token d'accès\nconst newToken=response.headers['x-new-access-token'];if(newToken){// Mettre à jour le token dans localStorage\nlocalStorage.setItem('authToken',newToken);}return response;},error=>{// Gérer les erreurs d'authentification (401)\nif(error.response&&error.response.status===401){var _error$response$data,_error$response$data$,_error$response$data2,_error$response$data3;// Vérifier si l'erreur est due à un token expiré\nconst isTokenExpired=((_error$response$data=error.response.data)===null||_error$response$data===void 0?void 0:(_error$response$data$=_error$response$data.error)===null||_error$response$data$===void 0?void 0:_error$response$data$.type)==='auth_token_expired'||((_error$response$data2=error.response.data)===null||_error$response$data2===void 0?void 0:(_error$response$data3=_error$response$data2.message)===null||_error$response$data3===void 0?void 0:_error$response$data3.includes('expired'));// Si le token est expiré, tenter de le rafraîchir automatiquement\n// Cette logique sera gérée par le service d'authentification\n// Pour l'instant, déconnecter l'utilisateur\nlocalStorage.removeItem('authToken');localStorage.removeItem('user');// Rediriger vers la page de connexion si nécessaire\nif(window.location.pathname!=='/login'){window.location.href='/login?expired=true';}}// Gérer les erreurs de timeout\nif(error.code==='ECONNABORTED'&&error.message.includes('timeout')){error.response={data:{error:{type:'timeout_error',message:'La requête a pris trop de temps à s\\'exécuter',severity:'warning'}}};}// Gérer les erreurs réseau\nif(!error.response){error.response={data:{error:{type:'network_error',message:'Impossible de se connecter au serveur',severity:'warning',details:error.message}}};}return Promise.reject(error);});/**\n * Fonction utilitaire pour créer des requêtes avec gestion de cache\n * @param {string} url - URL de la requête\n * @param {Object} options - Options de la requête\n * @returns {Promise} Promesse avec les données de la réponse\n */const createCachedRequest=function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{cacheDuration=5*60*1000,forceRefresh=false}=options;// Clé de cache unique pour cette requête\nconst cacheKey=`api_cache_${url}`;// Vérifier si les données sont en cache et toujours valides\nconst cachedData=localStorage.getItem(cacheKey);if(cachedData&&!forceRefresh){try{const{data,timestamp}=JSON.parse(cachedData);const isValid=Date.now()-timestamp<cacheDuration;if(isValid){return Promise.resolve(data);}}catch(error){// Ignorer les erreurs de parsing et continuer avec la requête\nconsole.warn('Erreur lors de la lecture du cache:',error);}}// Effectuer la requête API\nreturn api.get(url).then(response=>{// Mettre en cache les données\nlocalStorage.setItem(cacheKey,JSON.stringify({data:response.data,timestamp:Date.now()}));return response.data;});};export{api,USE_MOCK_DATA,createCachedRequest};export default api;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","USE_MOCK_DATA","REACT_APP_USE_MOCK_DATA","api","create","baseURL","headers","timeout","withCredentials","interceptors","request","use","config","token","localStorage","getItem","Authorization","method","params","_t","Date","now","error","Promise","reject","response","newToken","setItem","status","_error$response$data","_error$response$data$","_error$response$data2","_error$response$data3","isTokenExpired","data","type","message","includes","removeItem","window","location","pathname","href","code","severity","details","createCachedRequest","url","options","arguments","length","undefined","cacheDuration","forceRefresh","cacheKey","cachedData","timestamp","JSON","parse","isValid","resolve","console","warn","get","then","stringify"],"sources":["C:/Users/busin/CascadeProjects/grand-est-cyclisme-website-final (1) VERSION FINAL/client/src/services/api.js"],"sourcesContent":["/**\n * Service de configuration centrale pour les API\n * Ce fichier configure axios pour toutes les requêtes API\n */\nimport axios from 'axios';\n\n// Récupérer l'URL de base depuis les variables d'environnement\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';\nconst USE_MOCK_DATA = process.env.REACT_APP_USE_MOCK_DATA === 'true';\n\n// Création d'une instance axios avec la configuration de base\nconst api = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  // Ajouter un timeout par défaut pour éviter les requêtes bloquées indéfiniment\n  timeout: 30000, // 30 secondes\n  // Activer les credentials pour les cookies\n  withCredentials: true\n});\n\n// Intercepteur pour ajouter le token d'authentification JWT à chaque requête\napi.interceptors.request.use(\n  (config) => {\n    // Récupérer le token depuis les cookies ou localStorage\n    // Note: Les cookies httpOnly ne sont pas accessibles via JavaScript\n    // mais le token peut être stocké dans localStorage pour la compatibilité\n    const token = localStorage.getItem('authToken');\n    \n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // Ajouter un timestamp pour éviter la mise en cache des requêtes GET\n    if (config.method === 'get') {\n      config.params = {\n        ...config.params,\n        _t: Date.now()\n      };\n    }\n    \n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\n// Intercepteur pour gérer les réponses et les erreurs\napi.interceptors.response.use(\n  (response) => {\n    // Vérifier si la réponse contient un nouveau token d'accès\n    const newToken = response.headers['x-new-access-token'];\n    if (newToken) {\n      // Mettre à jour le token dans localStorage\n      localStorage.setItem('authToken', newToken);\n    }\n    \n    return response;\n  },\n  (error) => {\n    // Gérer les erreurs d'authentification (401)\n    if (error.response && error.response.status === 401) {\n      // Vérifier si l'erreur est due à un token expiré\n      const isTokenExpired = \n        error.response.data?.error?.type === 'auth_token_expired' ||\n        error.response.data?.message?.includes('expired');\n      \n      // Si le token est expiré, tenter de le rafraîchir automatiquement\n      // Cette logique sera gérée par le service d'authentification\n      \n      // Pour l'instant, déconnecter l'utilisateur\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('user');\n      \n      // Rediriger vers la page de connexion si nécessaire\n      if (window.location.pathname !== '/login') {\n        window.location.href = '/login?expired=true';\n      }\n    }\n    \n    // Gérer les erreurs de timeout\n    if (error.code === 'ECONNABORTED' && error.message.includes('timeout')) {\n      error.response = {\n        data: {\n          error: {\n            type: 'timeout_error',\n            message: 'La requête a pris trop de temps à s\\'exécuter',\n            severity: 'warning'\n          }\n        }\n      };\n    }\n    \n    // Gérer les erreurs réseau\n    if (!error.response) {\n      error.response = {\n        data: {\n          error: {\n            type: 'network_error',\n            message: 'Impossible de se connecter au serveur',\n            severity: 'warning',\n            details: error.message\n          }\n        }\n      };\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n/**\n * Fonction utilitaire pour créer des requêtes avec gestion de cache\n * @param {string} url - URL de la requête\n * @param {Object} options - Options de la requête\n * @returns {Promise} Promesse avec les données de la réponse\n */\nconst createCachedRequest = (url, options = {}) => {\n  const { cacheDuration = 5 * 60 * 1000, forceRefresh = false } = options;\n  \n  // Clé de cache unique pour cette requête\n  const cacheKey = `api_cache_${url}`;\n  \n  // Vérifier si les données sont en cache et toujours valides\n  const cachedData = localStorage.getItem(cacheKey);\n  if (cachedData && !forceRefresh) {\n    try {\n      const { data, timestamp } = JSON.parse(cachedData);\n      const isValid = Date.now() - timestamp < cacheDuration;\n      \n      if (isValid) {\n        return Promise.resolve(data);\n      }\n    } catch (error) {\n      // Ignorer les erreurs de parsing et continuer avec la requête\n      console.warn('Erreur lors de la lecture du cache:', error);\n    }\n  }\n  \n  // Effectuer la requête API\n  return api.get(url)\n    .then(response => {\n      // Mettre en cache les données\n      localStorage.setItem(cacheKey, JSON.stringify({\n        data: response.data,\n        timestamp: Date.now()\n      }));\n      \n      return response.data;\n    });\n};\n\nexport { api, USE_MOCK_DATA, createCachedRequest };\nexport default api;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}