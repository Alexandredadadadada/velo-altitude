{"ast":null,"code":"/**\n * Service de configuration des timeouts et opérations asynchrones\n * Remplace les timeouts codés en dur par des valeurs configurables\n * et implémente des stratégies de retry avancées\n */import featureFlagsService from'./featureFlags';// Configuration par défaut des timeouts (en millisecondes)\nconst DEFAULT_TIMEOUT_CONFIG={// Timeouts pour les opérations réseau\napi:{standard:10000,// 10 secondes pour les requêtes API standard\nlong:30000,// 30 secondes pour les opérations plus longues\ndownload:60000,// 60 secondes pour les téléchargements\nupload:120000// 120 secondes pour les uploads\n},// Timeouts pour les opérations UI\nui:{toast:3000,// 3 secondes pour les notifications toast\nautoClose:5000,// 5 secondes pour la fermeture automatique des dialogues\nanimation:300,// 300ms pour les animations UI\ndebounce:300,// 300ms pour le debounce des entrées utilisateur\nthrottle:100// 100ms pour le throttle des événements fréquents\n},// Timeouts pour les fonctionnalités spécifiques\nfeatures:{nutrition:{calculation:8000,// 8 secondes pour les calculs nutritionnels\nsynchronization:15000// 15 secondes pour synchroniser le journal nutritionnel\n},training:{planGeneration:20000,// 20 secondes pour générer un plan d'entraînement\nrouteCalculation:30000// 30 secondes pour calculer un itinéraire\n},visualization3D:{load:25000,// 25 secondes pour charger une visualisation 3D\nrender:5000// 5 secondes pour le rendu initial\n},weatherData:{forecast:12000,// 12 secondes pour obtenir des prévisions météo\nhistorical:20000// 20 secondes pour des données historiques\n}},// Configurations pour les retries\nretry:{maxAttempts:3,// Nombre maximum de tentatives\nbaseDelay:1000,// Délai initial entre les tentatives (1 seconde)\nmaxDelay:15000,// Délai maximum entre les tentatives (15 secondes)\nfactor:2// Facteur pour le backoff exponentiel\n}};/**\n * Classe principale du service de timeout configurable\n */class TimeoutConfigService{constructor(){this.config={...DEFAULT_TIMEOUT_CONFIG};this.activeTimeouts=new Map();this.activeIntervals=new Map();this.pendingOperations=new Map();this.isInitialized=false;}/**\n   * Initialise le service avec les configurations personnalisées\n   * @param {Object} customConfig Configuration personnalisée à fusionner\n   */initialize(){let customConfig=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(this.isInitialized)return;try{// Charger depuis localStorage si disponible\nconst storedConfig=localStorage.getItem('timeout_config');if(storedConfig){try{const parsedConfig=JSON.parse(storedConfig);this.config=this.mergeConfigs(this.config,parsedConfig);}catch(error){console.error('Erreur lors du parsing de la configuration des timeouts:',error);}}// Appliquer les configurations personnalisées\nif(customConfig&&Object.keys(customConfig).length>0){this.config=this.mergeConfigs(this.config,customConfig);}this.isInitialized=true;console.info('Service de configuration des timeouts initialisé');}catch(error){console.error('Erreur lors de l\\'initialisation du service de timeouts:',error);// Fallback à la configuration par défaut\nthis.config={...DEFAULT_TIMEOUT_CONFIG};this.isInitialized=true;}}/**\n   * Fusionne deux objets de configuration de manière récursive\n   * @param {Object} baseConfig Configuration de base\n   * @param {Object} overrideConfig Configuration à appliquer\n   * @returns {Object} Configuration fusionnée\n   */mergeConfigs(baseConfig,overrideConfig){const result={...baseConfig};for(const[key,value]of Object.entries(overrideConfig)){if(typeof value==='object'&&value!==null&&!Array.isArray(value)&&typeof baseConfig[key]==='object'){result[key]=this.mergeConfigs(baseConfig[key],value);}else{result[key]=value;}}return result;}/**\n   * Récupère une valeur de timeout depuis la configuration\n   * @param {string} path Chemin de la configuration (ex: 'api.standard')\n   * @param {number} defaultValue Valeur par défaut si le chemin n'existe pas\n   * @returns {number} Valeur du timeout\n   */getTimeout(path){let defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:10000;if(!this.isInitialized){this.initialize();}const keys=path.split('.');let value=this.config;for(const key of keys){if(value&&typeof value==='object'&&key in value){value=value[key];}else{return defaultValue;}}return typeof value==='number'?value:defaultValue;}/**\n   * Met à jour une valeur de timeout dans la configuration\n   * @param {string} path Chemin de la configuration (ex: 'api.standard')\n   * @param {number} value Nouvelle valeur pour le timeout\n   * @param {boolean} persist Si true, sauvegarde la configuration dans localStorage\n   */setTimeout(path,value){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!this.isInitialized){this.initialize();}if(typeof value!=='number'||value<0){console.error('Valeur de timeout invalide:',value);return;}const keys=path.split('.');let target=this.config;// Naviguer à travers l'objet config pour trouver le bon niveau\nfor(let i=0;i<keys.length-1;i++){const key=keys[i];if(!(key in target)){target[key]={};}target=target[key];}// Définir la valeur finale\nconst lastKey=keys[keys.length-1];target[lastKey]=value;// Persister si demandé\nif(persist){localStorage.setItem('timeout_config',JSON.stringify(this.config));}}/**\n   * Crée un timeout avec suivi\n   * @param {Function} callback Fonction à exécuter\n   * @param {number} delay Délai en millisecondes\n   * @param {string} id Identifiant optionnel du timeout\n   * @returns {string} Identifiant du timeout\n   */setTimeout(callback,delay){let id=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!this.isInitialized){this.initialize();}// Générer un ID unique si non fourni\nconst timeoutId=id||`timeout_${Date.now()}_${Math.random().toString(36).substring(2,9)}`;// Créer le timeout\nconst handle=setTimeout(()=>{this.activeTimeouts.delete(timeoutId);callback();},delay);// Enregistrer le timeout\nthis.activeTimeouts.set(timeoutId,{handle,created:Date.now(),delay,expires:Date.now()+delay});return timeoutId;}/**\n   * Crée un interval avec suivi\n   * @param {Function} callback Fonction à exécuter\n   * @param {number} delay Délai en millisecondes\n   * @param {string} id Identifiant optionnel de l'interval\n   * @returns {string} Identifiant de l'interval\n   */setInterval(callback,delay){let id=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!this.isInitialized){this.initialize();}// Générer un ID unique si non fourni\nconst intervalId=id||`interval_${Date.now()}_${Math.random().toString(36).substring(2,9)}`;// Créer l'interval\nconst handle=setInterval(callback,delay);// Enregistrer l'interval\nthis.activeIntervals.set(intervalId,{handle,created:Date.now(),delay});return intervalId;}/**\n   * Annule un timeout par son identifiant\n   * @param {string} timeoutId Identifiant du timeout\n   * @returns {boolean} True si le timeout a été annulé\n   */clearTimeout(timeoutId){if(this.activeTimeouts.has(timeoutId)){const{handle}=this.activeTimeouts.get(timeoutId);clearTimeout(handle);this.activeTimeouts.delete(timeoutId);return true;}return false;}/**\n   * Annule un interval par son identifiant\n   * @param {string} intervalId Identifiant de l'interval\n   * @returns {boolean} True si l'interval a été annulé\n   */clearInterval(intervalId){if(this.activeIntervals.has(intervalId)){const{handle}=this.activeIntervals.get(intervalId);clearInterval(handle);this.activeIntervals.delete(intervalId);return true;}return false;}/**\n   * Exécute une fonction avec un timeout configurable\n   * @param {Function} fn Fonction à exécuter (Promise)\n   * @param {string} timeoutPath Chemin de la configuration du timeout\n   * @param {Object} options Options supplémentaires\n   * @returns {Promise} Résultat de la fonction ou rejet en cas de timeout\n   */async withTimeout(fn,timeoutPath){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!this.isInitialized){this.initialize();}const{defaultTimeout=10000,onTimeout=null,id=null,abortable=false}=options;// Récupérer la valeur de timeout\nconst timeout=this.getTimeout(timeoutPath,defaultTimeout);// Générer un ID pour cette opération\nconst operationId=id||`operation_${Date.now()}_${Math.random().toString(36).substring(2,9)}`;// Créer un AbortController pour pouvoir annuler l'opération si nécessaire\nconst controller=abortable?new AbortController():null;const signal=controller?controller.signal:null;// Enregistrer l'opération\nthis.pendingOperations.set(operationId,{id:operationId,started:Date.now(),timeout,controller,timeoutPath});return new Promise((resolve,reject)=>{// Créer le timeout\nconst timeoutId=this.setTimeout(()=>{// Nettoyer\nthis.pendingOperations.delete(operationId);// Annuler l'opération si possible\nif(controller){controller.abort();}// Callback de timeout personnalisé\nif(onTimeout){onTimeout(operationId,timeout);}reject(new Error(`Opération ${operationId} expirée après ${timeout}ms`));},timeout,`timeout_for_${operationId}`);// Exécuter la fonction\nPromise.resolve().then(()=>fn(signal)).then(result=>{// Succès, nettoyer\nthis.clearTimeout(timeoutId);this.pendingOperations.delete(operationId);resolve(result);}).catch(error=>{// Erreur, nettoyer\nthis.clearTimeout(timeoutId);this.pendingOperations.delete(operationId);reject(error);});});}/**\n   * Exécute une fonction avec retry automatique en cas d'échec\n   * @param {Function} fn Fonction à exécuter (Promise)\n   * @param {Object} options Options pour le retry\n   * @returns {Promise} Résultat de la fonction\n   */async withRetry(fn){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!this.isInitialized){this.initialize();}const{maxAttempts=this.config.retry.maxAttempts,baseDelay=this.config.retry.baseDelay,maxDelay=this.config.retry.maxDelay,factor=this.config.retry.factor,shouldRetry=null,onRetry=null,timeoutPath=null}=options;let attempt=0;const execute=async()=>{try{attempt++;// Exécuter avec timeout si spécifié\nif(timeoutPath){return await this.withTimeout(fn,timeoutPath);}else{return await fn();}}catch(error){// Vérifier si on doit réessayer\nconst canRetry=attempt<maxAttempts&&(!shouldRetry||shouldRetry(error,attempt));if(!canRetry){throw error;}// Calculer le délai avec backoff exponentiel\nconst delay=Math.min(baseDelay*Math.pow(factor,attempt-1),maxDelay);// Notifier de la nouvelle tentative\nif(onRetry){onRetry(error,attempt,delay);}// Attendre avant de réessayer\nawait new Promise(resolve=>setTimeout(resolve,delay));// Réessayer\nreturn execute();}};return execute();}/**\n   * Exécute plusieurs fonctions en parallèle avec un timeout global\n   * @param {Array<Function>} fns Fonctions à exécuter\n   * @param {string} timeoutPath Chemin de la configuration du timeout\n   * @param {Object} options Options supplémentaires\n   * @returns {Promise<Array>} Résultats des fonctions\n   */async withParallelTimeout(fns,timeoutPath){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!this.isInitialized){this.initialize();}const{defaultTimeout=30000,allOrNothing=false,onTimeout=null}=options;const timeout=this.getTimeout(timeoutPath,defaultTimeout);const operationId=`parallel_${Date.now()}_${Math.random().toString(36).substring(2,9)}`;return new Promise((resolve,reject)=>{// Créer le timeout global\nconst timeoutId=this.setTimeout(()=>{if(onTimeout){onTimeout(operationId,timeout);}if(allOrNothing){reject(new Error(`Opérations parallèles expirées après ${timeout}ms`));}else{// Résoudre avec les résultats partiels et des erreurs pour les opérations en timeout\nresolve(promises.map((p,i)=>{return p._settled?p._result:new Error(`Opération ${i} expirée`);}));}},timeout,`timeout_for_${operationId}`);// Exécuter les fonctions avec tracking\nconst promises=fns.map((fn,i)=>{const p=Promise.resolve().then(()=>fn());// Ajouter des propriétés pour le tracking\np._settled=false;p._result=null;return p.then(result=>{p._settled=true;p._result=result;return result;}).catch(error=>{p._settled=true;p._result=error;throw error;});});// Attendre toutes les fonctions\nPromise.all(promises).then(results=>{this.clearTimeout(timeoutId);resolve(results);}).catch(error=>{if(allOrNothing){this.clearTimeout(timeoutId);reject(error);}else{// En mode partiel, on attend que toutes les promesses soient résolues/rejetées\nPromise.allSettled(promises).then(()=>{this.clearTimeout(timeoutId);resolve(promises.map(p=>p._result));});}});});}/**\n   * Exécute une fonction avec un debounce\n   * @param {Function} fn Fonction à exécuter\n   * @param {number} delay Délai de debounce\n   * @param {Object} options Options supplémentaires\n   * @returns {Function} Fonction avec debounce\n   */debounce(fn){let delay=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!this.isInitialized){this.initialize();}const{timeoutPath='ui.debounce',leading=false,trailing=true,maxWait=null}=options;const actualDelay=delay||this.getTimeout(timeoutPath,300);let timeoutId=null;let lastArgs=null;let lastThis=null;let lastCallTime=0;let lastInvokeTime=0;function invokeFunc(){const args=lastArgs;const thisArg=lastThis;lastArgs=lastThis=null;lastInvokeTime=Date.now();return fn.apply(thisArg,args);}function shouldInvoke(){const time=Date.now();const timeSinceLastCall=time-lastCallTime;const timeSinceLastInvoke=time-lastInvokeTime;return lastCallTime===0||timeSinceLastCall>=actualDelay||maxWait!==null&&timeSinceLastInvoke>=maxWait;}function trailingEdge(){timeoutId=null;if(trailing&&lastArgs){return invokeFunc();}lastArgs=lastThis=null;return null;}function leadingEdge(){lastInvokeTime=Date.now();// Reset le timeout\ntimeoutId=setTimeout(trailingEdge,actualDelay);return leading?invokeFunc():null;}function cancel(){if(timeoutId!==null){clearTimeout(timeoutId);timeoutId=null;}lastArgs=lastThis=null;lastCallTime=lastInvokeTime=0;}function flush(){return timeoutId===null?null:trailingEdge();}function debounced(){const time=Date.now();const isInvoking=shouldInvoke();for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}lastArgs=args;lastThis=this;lastCallTime=time;if(isInvoking){if(timeoutId===null){return leadingEdge();}if(maxWait!==null){// Gérer les appels pendant un maxWait\ntimeoutId=setTimeout(trailingEdge,actualDelay);return invokeFunc();}}if(timeoutId===null){timeoutId=setTimeout(trailingEdge,actualDelay);}return null;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**\n   * Exécute une fonction avec un throttle\n   * @param {Function} fn Fonction à exécuter\n   * @param {number} delay Délai de throttle\n   * @param {Object} options Options supplémentaires\n   * @returns {Function} Fonction avec throttle\n   */throttle(fn){let delay=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!this.isInitialized){this.initialize();}const{timeoutPath='ui.throttle',leading=true,trailing=true}=options;const actualDelay=delay||this.getTimeout(timeoutPath,100);return this.debounce(fn,actualDelay,{leading,trailing,maxWait:actualDelay});}/**\n   * Libère les ressources en annulant tous les timeouts et intervals actifs\n   */dispose(){// Arrêter tous les timeouts\nfor(const[id,{handle}]of this.activeTimeouts.entries()){clearTimeout(handle);}// Arrêter tous les intervals\nfor(const[id,{handle}]of this.activeIntervals.entries()){clearInterval(handle);}// Réinitialiser les collections\nthis.activeTimeouts.clear();this.activeIntervals.clear();this.pendingOperations.clear();console.info('Service de timeout libéré');}}// Créer une instance singleton du service\nconst timeoutConfigService=new TimeoutConfigService();export{DEFAULT_TIMEOUT_CONFIG};export default timeoutConfigService;","map":{"version":3,"names":["featureFlagsService","DEFAULT_TIMEOUT_CONFIG","api","standard","long","download","upload","ui","toast","autoClose","animation","debounce","throttle","features","nutrition","calculation","synchronization","training","planGeneration","routeCalculation","visualization3D","load","render","weatherData","forecast","historical","retry","maxAttempts","baseDelay","maxDelay","factor","TimeoutConfigService","constructor","config","activeTimeouts","Map","activeIntervals","pendingOperations","isInitialized","initialize","customConfig","arguments","length","undefined","storedConfig","localStorage","getItem","parsedConfig","JSON","parse","mergeConfigs","error","console","Object","keys","info","baseConfig","overrideConfig","result","key","value","entries","Array","isArray","getTimeout","path","defaultValue","split","setTimeout","persist","target","i","lastKey","setItem","stringify","callback","delay","id","timeoutId","Date","now","Math","random","toString","substring","handle","delete","set","created","expires","setInterval","intervalId","clearTimeout","has","get","clearInterval","withTimeout","fn","timeoutPath","options","defaultTimeout","onTimeout","abortable","timeout","operationId","controller","AbortController","signal","started","Promise","resolve","reject","abort","Error","then","catch","withRetry","shouldRetry","onRetry","attempt","execute","canRetry","min","pow","withParallelTimeout","fns","allOrNothing","promises","map","p","_settled","_result","all","results","allSettled","leading","trailing","maxWait","actualDelay","lastArgs","lastThis","lastCallTime","lastInvokeTime","invokeFunc","args","thisArg","apply","shouldInvoke","time","timeSinceLastCall","timeSinceLastInvoke","trailingEdge","leadingEdge","cancel","flush","debounced","isInvoking","_len","_key","dispose","clear","timeoutConfigService"],"sources":["C:/Users/busin/CascadeProjects/grand-est-cyclisme-website-final (1) VERSION FINAL/client/src/services/timeoutConfig.js"],"sourcesContent":["/**\n * Service de configuration des timeouts et opérations asynchrones\n * Remplace les timeouts codés en dur par des valeurs configurables\n * et implémente des stratégies de retry avancées\n */\nimport featureFlagsService from './featureFlags';\n\n// Configuration par défaut des timeouts (en millisecondes)\nconst DEFAULT_TIMEOUT_CONFIG = {\n  // Timeouts pour les opérations réseau\n  api: {\n    standard: 10000,        // 10 secondes pour les requêtes API standard\n    long: 30000,            // 30 secondes pour les opérations plus longues\n    download: 60000,        // 60 secondes pour les téléchargements\n    upload: 120000          // 120 secondes pour les uploads\n  },\n  \n  // Timeouts pour les opérations UI\n  ui: {\n    toast: 3000,            // 3 secondes pour les notifications toast\n    autoClose: 5000,        // 5 secondes pour la fermeture automatique des dialogues\n    animation: 300,         // 300ms pour les animations UI\n    debounce: 300,          // 300ms pour le debounce des entrées utilisateur\n    throttle: 100           // 100ms pour le throttle des événements fréquents\n  },\n  \n  // Timeouts pour les fonctionnalités spécifiques\n  features: {\n    nutrition: {\n      calculation: 8000,    // 8 secondes pour les calculs nutritionnels\n      synchronization: 15000 // 15 secondes pour synchroniser le journal nutritionnel\n    },\n    training: {\n      planGeneration: 20000, // 20 secondes pour générer un plan d'entraînement\n      routeCalculation: 30000 // 30 secondes pour calculer un itinéraire\n    },\n    visualization3D: {\n      load: 25000,          // 25 secondes pour charger une visualisation 3D\n      render: 5000          // 5 secondes pour le rendu initial\n    },\n    weatherData: {\n      forecast: 12000,      // 12 secondes pour obtenir des prévisions météo\n      historical: 20000     // 20 secondes pour des données historiques\n    }\n  },\n  \n  // Configurations pour les retries\n  retry: {\n    maxAttempts: 3,         // Nombre maximum de tentatives\n    baseDelay: 1000,        // Délai initial entre les tentatives (1 seconde)\n    maxDelay: 15000,        // Délai maximum entre les tentatives (15 secondes)\n    factor: 2               // Facteur pour le backoff exponentiel\n  }\n};\n\n/**\n * Classe principale du service de timeout configurable\n */\nclass TimeoutConfigService {\n  constructor() {\n    this.config = { ...DEFAULT_TIMEOUT_CONFIG };\n    this.activeTimeouts = new Map();\n    this.activeIntervals = new Map();\n    this.pendingOperations = new Map();\n    this.isInitialized = false;\n  }\n\n  /**\n   * Initialise le service avec les configurations personnalisées\n   * @param {Object} customConfig Configuration personnalisée à fusionner\n   */\n  initialize(customConfig = {}) {\n    if (this.isInitialized) return;\n    \n    try {\n      // Charger depuis localStorage si disponible\n      const storedConfig = localStorage.getItem('timeout_config');\n      \n      if (storedConfig) {\n        try {\n          const parsedConfig = JSON.parse(storedConfig);\n          this.config = this.mergeConfigs(this.config, parsedConfig);\n        } catch (error) {\n          console.error('Erreur lors du parsing de la configuration des timeouts:', error);\n        }\n      }\n      \n      // Appliquer les configurations personnalisées\n      if (customConfig && Object.keys(customConfig).length > 0) {\n        this.config = this.mergeConfigs(this.config, customConfig);\n      }\n      \n      this.isInitialized = true;\n      console.info('Service de configuration des timeouts initialisé');\n    } catch (error) {\n      console.error('Erreur lors de l\\'initialisation du service de timeouts:', error);\n      // Fallback à la configuration par défaut\n      this.config = { ...DEFAULT_TIMEOUT_CONFIG };\n      this.isInitialized = true;\n    }\n  }\n\n  /**\n   * Fusionne deux objets de configuration de manière récursive\n   * @param {Object} baseConfig Configuration de base\n   * @param {Object} overrideConfig Configuration à appliquer\n   * @returns {Object} Configuration fusionnée\n   */\n  mergeConfigs(baseConfig, overrideConfig) {\n    const result = { ...baseConfig };\n    \n    for (const [key, value] of Object.entries(overrideConfig)) {\n      if (\n        typeof value === 'object' && \n        value !== null && \n        !Array.isArray(value) &&\n        typeof baseConfig[key] === 'object'\n      ) {\n        result[key] = this.mergeConfigs(baseConfig[key], value);\n      } else {\n        result[key] = value;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Récupère une valeur de timeout depuis la configuration\n   * @param {string} path Chemin de la configuration (ex: 'api.standard')\n   * @param {number} defaultValue Valeur par défaut si le chemin n'existe pas\n   * @returns {number} Valeur du timeout\n   */\n  getTimeout(path, defaultValue = 10000) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    const keys = path.split('.');\n    let value = this.config;\n    \n    for (const key of keys) {\n      if (value && typeof value === 'object' && key in value) {\n        value = value[key];\n      } else {\n        return defaultValue;\n      }\n    }\n    \n    return typeof value === 'number' ? value : defaultValue;\n  }\n\n  /**\n   * Met à jour une valeur de timeout dans la configuration\n   * @param {string} path Chemin de la configuration (ex: 'api.standard')\n   * @param {number} value Nouvelle valeur pour le timeout\n   * @param {boolean} persist Si true, sauvegarde la configuration dans localStorage\n   */\n  setTimeout(path, value, persist = true) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    if (typeof value !== 'number' || value < 0) {\n      console.error('Valeur de timeout invalide:', value);\n      return;\n    }\n    \n    const keys = path.split('.');\n    let target = this.config;\n    \n    // Naviguer à travers l'objet config pour trouver le bon niveau\n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n      \n      if (!(key in target)) {\n        target[key] = {};\n      }\n      \n      target = target[key];\n    }\n    \n    // Définir la valeur finale\n    const lastKey = keys[keys.length - 1];\n    target[lastKey] = value;\n    \n    // Persister si demandé\n    if (persist) {\n      localStorage.setItem('timeout_config', JSON.stringify(this.config));\n    }\n  }\n\n  /**\n   * Crée un timeout avec suivi\n   * @param {Function} callback Fonction à exécuter\n   * @param {number} delay Délai en millisecondes\n   * @param {string} id Identifiant optionnel du timeout\n   * @returns {string} Identifiant du timeout\n   */\n  setTimeout(callback, delay, id = null) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    // Générer un ID unique si non fourni\n    const timeoutId = id || `timeout_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Créer le timeout\n    const handle = setTimeout(() => {\n      this.activeTimeouts.delete(timeoutId);\n      callback();\n    }, delay);\n    \n    // Enregistrer le timeout\n    this.activeTimeouts.set(timeoutId, {\n      handle,\n      created: Date.now(),\n      delay,\n      expires: Date.now() + delay\n    });\n    \n    return timeoutId;\n  }\n\n  /**\n   * Crée un interval avec suivi\n   * @param {Function} callback Fonction à exécuter\n   * @param {number} delay Délai en millisecondes\n   * @param {string} id Identifiant optionnel de l'interval\n   * @returns {string} Identifiant de l'interval\n   */\n  setInterval(callback, delay, id = null) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    // Générer un ID unique si non fourni\n    const intervalId = id || `interval_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Créer l'interval\n    const handle = setInterval(callback, delay);\n    \n    // Enregistrer l'interval\n    this.activeIntervals.set(intervalId, {\n      handle,\n      created: Date.now(),\n      delay\n    });\n    \n    return intervalId;\n  }\n\n  /**\n   * Annule un timeout par son identifiant\n   * @param {string} timeoutId Identifiant du timeout\n   * @returns {boolean} True si le timeout a été annulé\n   */\n  clearTimeout(timeoutId) {\n    if (this.activeTimeouts.has(timeoutId)) {\n      const { handle } = this.activeTimeouts.get(timeoutId);\n      clearTimeout(handle);\n      this.activeTimeouts.delete(timeoutId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Annule un interval par son identifiant\n   * @param {string} intervalId Identifiant de l'interval\n   * @returns {boolean} True si l'interval a été annulé\n   */\n  clearInterval(intervalId) {\n    if (this.activeIntervals.has(intervalId)) {\n      const { handle } = this.activeIntervals.get(intervalId);\n      clearInterval(handle);\n      this.activeIntervals.delete(intervalId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Exécute une fonction avec un timeout configurable\n   * @param {Function} fn Fonction à exécuter (Promise)\n   * @param {string} timeoutPath Chemin de la configuration du timeout\n   * @param {Object} options Options supplémentaires\n   * @returns {Promise} Résultat de la fonction ou rejet en cas de timeout\n   */\n  async withTimeout(fn, timeoutPath, options = {}) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    const {\n      defaultTimeout = 10000,\n      onTimeout = null,\n      id = null,\n      abortable = false\n    } = options;\n    \n    // Récupérer la valeur de timeout\n    const timeout = this.getTimeout(timeoutPath, defaultTimeout);\n    \n    // Générer un ID pour cette opération\n    const operationId = id || `operation_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Créer un AbortController pour pouvoir annuler l'opération si nécessaire\n    const controller = abortable ? new AbortController() : null;\n    const signal = controller ? controller.signal : null;\n    \n    // Enregistrer l'opération\n    this.pendingOperations.set(operationId, {\n      id: operationId,\n      started: Date.now(),\n      timeout,\n      controller,\n      timeoutPath\n    });\n    \n    return new Promise((resolve, reject) => {\n      // Créer le timeout\n      const timeoutId = this.setTimeout(() => {\n        // Nettoyer\n        this.pendingOperations.delete(operationId);\n        \n        // Annuler l'opération si possible\n        if (controller) {\n          controller.abort();\n        }\n        \n        // Callback de timeout personnalisé\n        if (onTimeout) {\n          onTimeout(operationId, timeout);\n        }\n        \n        reject(new Error(`Opération ${operationId} expirée après ${timeout}ms`));\n      }, timeout, `timeout_for_${operationId}`);\n      \n      // Exécuter la fonction\n      Promise.resolve()\n        .then(() => fn(signal))\n        .then(result => {\n          // Succès, nettoyer\n          this.clearTimeout(timeoutId);\n          this.pendingOperations.delete(operationId);\n          resolve(result);\n        })\n        .catch(error => {\n          // Erreur, nettoyer\n          this.clearTimeout(timeoutId);\n          this.pendingOperations.delete(operationId);\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Exécute une fonction avec retry automatique en cas d'échec\n   * @param {Function} fn Fonction à exécuter (Promise)\n   * @param {Object} options Options pour le retry\n   * @returns {Promise} Résultat de la fonction\n   */\n  async withRetry(fn, options = {}) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    const {\n      maxAttempts = this.config.retry.maxAttempts,\n      baseDelay = this.config.retry.baseDelay,\n      maxDelay = this.config.retry.maxDelay,\n      factor = this.config.retry.factor,\n      shouldRetry = null,\n      onRetry = null,\n      timeoutPath = null\n    } = options;\n    \n    let attempt = 0;\n    \n    const execute = async () => {\n      try {\n        attempt++;\n        \n        // Exécuter avec timeout si spécifié\n        if (timeoutPath) {\n          return await this.withTimeout(fn, timeoutPath);\n        } else {\n          return await fn();\n        }\n      } catch (error) {\n        // Vérifier si on doit réessayer\n        const canRetry = \n          attempt < maxAttempts && \n          (!shouldRetry || shouldRetry(error, attempt));\n        \n        if (!canRetry) {\n          throw error;\n        }\n        \n        // Calculer le délai avec backoff exponentiel\n        const delay = Math.min(\n          baseDelay * Math.pow(factor, attempt - 1),\n          maxDelay\n        );\n        \n        // Notifier de la nouvelle tentative\n        if (onRetry) {\n          onRetry(error, attempt, delay);\n        }\n        \n        // Attendre avant de réessayer\n        await new Promise(resolve => setTimeout(resolve, delay));\n        \n        // Réessayer\n        return execute();\n      }\n    };\n    \n    return execute();\n  }\n\n  /**\n   * Exécute plusieurs fonctions en parallèle avec un timeout global\n   * @param {Array<Function>} fns Fonctions à exécuter\n   * @param {string} timeoutPath Chemin de la configuration du timeout\n   * @param {Object} options Options supplémentaires\n   * @returns {Promise<Array>} Résultats des fonctions\n   */\n  async withParallelTimeout(fns, timeoutPath, options = {}) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    const {\n      defaultTimeout = 30000,\n      allOrNothing = false,\n      onTimeout = null\n    } = options;\n    \n    const timeout = this.getTimeout(timeoutPath, defaultTimeout);\n    const operationId = `parallel_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    return new Promise((resolve, reject) => {\n      // Créer le timeout global\n      const timeoutId = this.setTimeout(() => {\n        if (onTimeout) {\n          onTimeout(operationId, timeout);\n        }\n        \n        if (allOrNothing) {\n          reject(new Error(`Opérations parallèles expirées après ${timeout}ms`));\n        } else {\n          // Résoudre avec les résultats partiels et des erreurs pour les opérations en timeout\n          resolve(promises.map((p, i) => {\n            return p._settled ? p._result : new Error(`Opération ${i} expirée`);\n          }));\n        }\n      }, timeout, `timeout_for_${operationId}`);\n      \n      // Exécuter les fonctions avec tracking\n      const promises = fns.map((fn, i) => {\n        const p = Promise.resolve().then(() => fn());\n        \n        // Ajouter des propriétés pour le tracking\n        p._settled = false;\n        p._result = null;\n        \n        return p.then(result => {\n          p._settled = true;\n          p._result = result;\n          return result;\n        }).catch(error => {\n          p._settled = true;\n          p._result = error;\n          throw error;\n        });\n      });\n      \n      // Attendre toutes les fonctions\n      Promise.all(promises)\n        .then(results => {\n          this.clearTimeout(timeoutId);\n          resolve(results);\n        })\n        .catch(error => {\n          if (allOrNothing) {\n            this.clearTimeout(timeoutId);\n            reject(error);\n          } else {\n            // En mode partiel, on attend que toutes les promesses soient résolues/rejetées\n            Promise.allSettled(promises).then(() => {\n              this.clearTimeout(timeoutId);\n              resolve(promises.map(p => p._result));\n            });\n          }\n        });\n    });\n  }\n\n  /**\n   * Exécute une fonction avec un debounce\n   * @param {Function} fn Fonction à exécuter\n   * @param {number} delay Délai de debounce\n   * @param {Object} options Options supplémentaires\n   * @returns {Function} Fonction avec debounce\n   */\n  debounce(fn, delay = null, options = {}) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    const {\n      timeoutPath = 'ui.debounce',\n      leading = false,\n      trailing = true,\n      maxWait = null\n    } = options;\n    \n    const actualDelay = delay || this.getTimeout(timeoutPath, 300);\n    let timeoutId = null;\n    let lastArgs = null;\n    let lastThis = null;\n    let lastCallTime = 0;\n    let lastInvokeTime = 0;\n    \n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      \n      lastArgs = lastThis = null;\n      lastInvokeTime = Date.now();\n      \n      return fn.apply(thisArg, args);\n    }\n    \n    function shouldInvoke() {\n      const time = Date.now();\n      const timeSinceLastCall = time - lastCallTime;\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      \n      return (\n        lastCallTime === 0 ||\n        timeSinceLastCall >= actualDelay ||\n        (maxWait !== null && timeSinceLastInvoke >= maxWait)\n      );\n    }\n    \n    function trailingEdge() {\n      timeoutId = null;\n      \n      if (trailing && lastArgs) {\n        return invokeFunc();\n      }\n      \n      lastArgs = lastThis = null;\n      return null;\n    }\n    \n    function leadingEdge() {\n      lastInvokeTime = Date.now();\n      \n      // Reset le timeout\n      timeoutId = setTimeout(trailingEdge, actualDelay);\n      \n      return leading ? invokeFunc() : null;\n    }\n    \n    function cancel() {\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n      \n      lastArgs = lastThis = null;\n      lastCallTime = lastInvokeTime = 0;\n    }\n    \n    function flush() {\n      return timeoutId === null ? null : trailingEdge();\n    }\n    \n    function debounced(...args) {\n      const time = Date.now();\n      const isInvoking = shouldInvoke();\n      \n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n      \n      if (isInvoking) {\n        if (timeoutId === null) {\n          return leadingEdge();\n        }\n        \n        if (maxWait !== null) {\n          // Gérer les appels pendant un maxWait\n          timeoutId = setTimeout(trailingEdge, actualDelay);\n          return invokeFunc();\n        }\n      }\n      \n      if (timeoutId === null) {\n        timeoutId = setTimeout(trailingEdge, actualDelay);\n      }\n      \n      return null;\n    }\n    \n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    \n    return debounced;\n  }\n\n  /**\n   * Exécute une fonction avec un throttle\n   * @param {Function} fn Fonction à exécuter\n   * @param {number} delay Délai de throttle\n   * @param {Object} options Options supplémentaires\n   * @returns {Function} Fonction avec throttle\n   */\n  throttle(fn, delay = null, options = {}) {\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    \n    const {\n      timeoutPath = 'ui.throttle',\n      leading = true,\n      trailing = true\n    } = options;\n    \n    const actualDelay = delay || this.getTimeout(timeoutPath, 100);\n    \n    return this.debounce(fn, actualDelay, {\n      leading,\n      trailing,\n      maxWait: actualDelay\n    });\n  }\n\n  /**\n   * Libère les ressources en annulant tous les timeouts et intervals actifs\n   */\n  dispose() {\n    // Arrêter tous les timeouts\n    for (const [id, { handle }] of this.activeTimeouts.entries()) {\n      clearTimeout(handle);\n    }\n    \n    // Arrêter tous les intervals\n    for (const [id, { handle }] of this.activeIntervals.entries()) {\n      clearInterval(handle);\n    }\n    \n    // Réinitialiser les collections\n    this.activeTimeouts.clear();\n    this.activeIntervals.clear();\n    this.pendingOperations.clear();\n    \n    console.info('Service de timeout libéré');\n  }\n}\n\n// Créer une instance singleton du service\nconst timeoutConfigService = new TimeoutConfigService();\n\nexport { DEFAULT_TIMEOUT_CONFIG };\nexport default timeoutConfigService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}