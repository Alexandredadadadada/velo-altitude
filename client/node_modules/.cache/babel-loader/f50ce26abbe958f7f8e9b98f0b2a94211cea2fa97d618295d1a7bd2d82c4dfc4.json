{"ast":null,"code":"/**\n * Service de cache API avancé\n * Permet de réduire les appels API redondants et d'améliorer les performances\n * Supporte plusieurs stratégies de cache, invalidation intelligente et persistance\n */import axios from'axios';import featureFlagsService from'./featureFlags';// Constantes pour les stratégies de cache\nconst CACHE_STRATEGIES={NETWORK_FIRST:'network-first',// Essaie le réseau, utilise le cache en fallback\nCACHE_FIRST:'cache-first',// Utilise le cache, fait appel au réseau si expiré ou absent\nSTALE_WHILE_REVALIDATE:'stale-while-revalidate',// Retourne le cache immédiatement et met à jour en arrière-plan\nNETWORK_ONLY:'network-only',// Toujours utiliser le réseau (désactive le cache)\nCACHE_ONLY:'cache-only'// Toujours utiliser le cache (mode hors ligne)\n};// Structure de l'élément de cache\nclass CacheItem{constructor(data){let params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.data=data;this.timestamp=Date.now();this.expiry=this.timestamp+(params.ttl||5*60*1000);// 5 minutes par défaut\nthis.staleExpiry=this.expiry+(params.staleTime||60*60*1000);// 1 heure de plus pour les données obsolètes\nthis.tags=params.tags||[];this.etag=params.etag||null;this.lastModified=params.lastModified||null;}isExpired(){return Date.now()>this.expiry;}isStale(){return this.isExpired()&&Date.now()<=this.staleExpiry;}// Méthode pour étendre la durée de vie du cache\nextend(additionalTime){this.expiry+=additionalTime;this.staleExpiry+=additionalTime;}}/**\n * Service principal de gestion du cache API\n */class ApiCacheService{constructor(){this.cache=new Map();this.pendingRequests=new Map();this.isInitialized=false;this.storageKey='api_cache_data';this.defaultTTL=5*60*1000;// 5 minutes par défaut\nthis.maxCacheSize=100;// Nombre maximum d'entrées dans le cache\nthis.defaultStrategy=CACHE_STRATEGIES.CACHE_FIRST;this.networkMonitor={isOnline:true,lastCheck:Date.now()};this.statistics={hits:0,misses:0,errors:0,networkCalls:0};this.ttlConfigKey='api_cache_ttl_config';this.categoryTTLs={};// Création d'une instance axios personnalisée\nthis.axiosInstance=axios.create({timeout:10000// 10 secondes de timeout par défaut\n});// Intercepteur pour ajouter les headers de cache\nthis.axiosInstance.interceptors.request.use(config=>{const cacheKey=this.generateCacheKey(config.url,config.params);// Ajouter les headers conditionnels si disponibles\nconst cachedItem=this.cache.get(cacheKey);if(cachedItem){if(cachedItem.etag){config.headers['If-None-Match']=cachedItem.etag;}if(cachedItem.lastModified){config.headers['If-Modified-Since']=cachedItem.lastModified;}}return config;});// Intercepteur pour gérer les réponses 304 Not Modified\nthis.axiosInstance.interceptors.response.use(response=>{// Capture des headers ETag et Last-Modified\nconst newHeaders={};if(response.headers.etag){newHeaders.etag=response.headers.etag;}if(response.headers['last-modified']){newHeaders.lastModified=response.headers['last-modified'];}// Ajouter les headers à la réponse pour utilisation dans le cache\nresponse.cacheHeaders=newHeaders;return response;},error=>{// Si 304 Not Modified, considérer comme un succès\nif(error.response&&error.response.status===304){const cacheKey=this.generateCacheKey(error.config.url,error.config.params);const cachedItem=this.cache.get(cacheKey);if(cachedItem){// Créer une réponse simulée avec les données du cache\nconst response={data:cachedItem.data,status:200,statusText:'OK (from cache)',headers:error.response.headers,config:error.config,fromCache:true};// Prolonger la durée de vie du cache\ncachedItem.extend(this.defaultTTL);this.cache.set(cacheKey,cachedItem);return response;}}return Promise.reject(error);});}/**\n   * Initialise le service de cache\n   * @returns {Promise<void>}\n   */async initialize(){if(this.isInitialized)return;try{// Charger les TTL spécifiques par catégorie depuis les feature flags\nawait this.loadTTLConfigurations();// Si le caching avancé est activé, charger depuis le stockage\nif(featureFlagsService.isEnabled('enableAdvancedCaching')){await this.loadCacheFromStorage();}// Configurer la surveillance réseau\nthis.setupNetworkMonitoring();// Configurer le nettoyage périodique du cache\nthis.setupPeriodicCleanup();this.isInitialized=true;console.info('Service de cache API initialisé',{cacheSize:this.cache.size,defaultTTL:this.formatDuration(this.defaultTTL)});}catch(error){console.error('Erreur lors de l\\'initialisation du cache API:',error);}}/**\n   * Configure la surveillance de la connexion réseau\n   */setupNetworkMonitoring(){if(typeof window!=='undefined'){// Détecter les changements de connectivité\nwindow.addEventListener('online',()=>{this.networkMonitor.isOnline=true;this.networkMonitor.lastCheck=Date.now();console.info('Connectivité rétablie - API Cache passe en mode en ligne');});window.addEventListener('offline',()=>{this.networkMonitor.isOnline=false;this.networkMonitor.lastCheck=Date.now();console.info('Connectivité perdue - API Cache passe en mode hors ligne');});// État initial\nthis.networkMonitor.isOnline=navigator.onLine;}}/**\n   * Configure le nettoyage périodique du cache\n   */setupPeriodicCleanup(){// Nettoyer toutes les heures\nconst CLEANUP_INTERVAL=60*60*1000;if(typeof window!=='undefined'){setInterval(()=>this.cleanupCache(),CLEANUP_INTERVAL);}}/**\n   * Nettoie le cache en supprimant les entrées expirées et en respectant la taille maximale\n   */cleanupCache(){if(this.cache.size===0)return;console.info('Nettoyage du cache API en cours...');const now=Date.now();let deleteCount=0;// Supprimer les entrées complètement expirées (même stale)\nfor(const[key,item]of this.cache.entries()){if(now>item.staleExpiry){this.cache.delete(key);deleteCount++;}}// Si le cache est toujours trop grand, supprimer les entrées les plus anciennes\nif(this.cache.size>this.maxCacheSize){const excess=this.cache.size-this.maxCacheSize;const entries=Array.from(this.cache.entries()).sort((a,b)=>a[1].timestamp-b[1].timestamp);for(let i=0;i<excess;i++){this.cache.delete(entries[i][0]);deleteCount++;}}console.info(`Nettoyage du cache terminé: ${deleteCount} entrées supprimées`);this.saveCacheToStorage();}/**\n   * Charge le cache depuis le localStorage\n   */async loadCacheFromStorage(){try{const storedCache=localStorage.getItem(this.storageKey);if(!storedCache)return;const parsedCache=JSON.parse(storedCache);const now=Date.now();let validEntries=0;// Ne charger que les entrées non complètement expirées\nObject.entries(parsedCache).forEach(_ref=>{let[key,value]=_ref;// Recréer l'objet CacheItem correctement avec ses méthodes\nconst cacheItem=new CacheItem(value.data,{ttl:value.expiry-value.timestamp,staleTime:value.staleExpiry-value.expiry,tags:value.tags,etag:value.etag,lastModified:value.lastModified});// Restaurer les timestamps originaux\ncacheItem.timestamp=value.timestamp;cacheItem.expiry=value.expiry;cacheItem.staleExpiry=value.staleExpiry;// Ne pas charger les entrées complètement expirées\nif(now<=cacheItem.staleExpiry){this.cache.set(key,cacheItem);validEntries++;}});console.info(`Cache chargé depuis le localStorage: ${validEntries} entrées valides`);}catch(error){console.error('Erreur lors du chargement du cache depuis le localStorage:',error);// Si erreur, démarrer avec un cache vide\nthis.cache.clear();}}/**\n   * Sauvegarde le cache dans le localStorage\n   */saveCacheToStorage(){try{// Convertir le Map en objet pour le stockage\nconst cacheObject={};for(const[key,value]of this.cache.entries()){cacheObject[key]={data:value.data,timestamp:value.timestamp,expiry:value.expiry,staleExpiry:value.staleExpiry,tags:value.tags,etag:value.etag,lastModified:value.lastModified};}localStorage.setItem(this.storageKey,JSON.stringify(cacheObject));}catch(error){console.error('Erreur lors de la sauvegarde du cache dans le localStorage:',error);}}/**\n   * Génère une clé de cache unique pour une URL et des paramètres\n   * @param {string} url URL de la requête\n   * @param {Object} params Paramètres de la requête\n   * @returns {string} Clé de cache unique\n   */generateCacheKey(url){let params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Normaliser l'URL\nconst normalizedUrl=url.toLowerCase().trim();// Trier les paramètres pour assurer la cohérence des clés\nconst sortedParams={};if(params){Object.keys(params).sort().forEach(key=>{sortedParams[key]=params[key];});}// Créer une clé unique\nreturn`${normalizedUrl}|${JSON.stringify(sortedParams)}`;}/**\n   * Effectue une requête GET avec gestion de cache\n   * @param {string} url URL de la requête\n   * @param {Object} options Options de la requête\n   * @param {Object} options.params Paramètres de la requête\n   * @param {string} options.strategy Stratégie de cache à utiliser\n   * @param {number} options.ttl Durée de vie du cache en millisecondes\n   * @param {Array<string>} options.tags Tags associés à cette entrée de cache\n   * @returns {Promise<any>} Données de la réponse\n   */async get(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Initialiser le service si ce n'est pas déjà fait\nif(!this.isInitialized){await this.initialize();}const{params={},strategy=this.defaultStrategy,tags=[]}=options;// Utiliser le TTL approprié pour cette URL\nconst ttl=this.getTTLForUrl(url,options);// Créer la clé de cache\nconst cacheKey=this.generateCacheKey(url,params);// Vérifier si la réponse est en cache\nconst cachedItem=this.cache.get(cacheKey);// Options de cache à utiliser pour la mise en cache\nconst cacheOptions={ttl,tags};// Vérifier si le caching est activé\nconst isCachingEnabled=featureFlagsService.isEnabled('enableApiCaching');// Si le caching est désactivé, faire un appel réseau direct\nif(!isCachingEnabled||strategy===CACHE_STRATEGIES.NETWORK_ONLY){return this.fetchFromNetwork(url,params);}// Gestion du mode hors ligne forcé\nif(strategy===CACHE_STRATEGIES.CACHE_ONLY){if(cachedItem){this.statistics.hits++;return{...cachedItem.data,fromCache:true};}else{this.statistics.misses++;throw new Error('Aucune donnée en cache et mode CACHE_ONLY activé');}}// Gestion du mode hors ligne en cas de perte de connectivité\nif(!this.networkMonitor.isOnline){if(cachedItem){console.info('Mode hors ligne - Utilisation du cache pour:',url);return{...cachedItem.data,fromCache:true};}else{throw new Error('Aucune donnée en cache et appareil hors ligne');}}// Stratégie CACHE_FIRST\nif(strategy===CACHE_STRATEGIES.CACHE_FIRST){if(cachedItem&&!cachedItem.isExpired()){this.statistics.hits++;return{...cachedItem.data,fromCache:true};}// Cache expiré ou absent\ntry{const response=await this.fetchFromNetwork(url,params);this.cacheResponse(cacheKey,response,cacheOptions);return response;}catch(error){// En cas d'erreur réseau, utiliser le cache même expiré si disponible\nif(cachedItem){console.warn('Erreur réseau - Utilisation du cache expiré pour:',url);return{...cachedItem.data,fromCache:true,stale:true};}throw error;}}// Stratégie STALE_WHILE_REVALIDATE\nif(strategy===CACHE_STRATEGIES.STALE_WHILE_REVALIDATE){// Si un élément est en cache, le retourner immédiatement\nif(cachedItem){// Mettre à jour en arrière-plan si expiré\nif(cachedItem.isExpired()){this.fetchFromNetworkAndUpdateCache(url,params,cacheKey,cacheOptions).catch(error=>console.error('Erreur lors de la mise à jour du cache en arrière-plan:',error));}this.statistics.hits++;return{...cachedItem.data,fromCache:true,stale:cachedItem.isExpired()};}// Rien en cache, faire un appel réseau\nconst response=await this.fetchFromNetwork(url,params);this.cacheResponse(cacheKey,response,cacheOptions);return response;}// Par défaut: NETWORK_FIRST\ntry{const response=await this.fetchFromNetwork(url,params);this.cacheResponse(cacheKey,response,cacheOptions);return response;}catch(error){// En cas d'erreur réseau, utiliser le cache si disponible\nif(cachedItem){console.warn('Erreur réseau - Utilisation du cache pour:',url);this.statistics.hits++;return{...cachedItem.data,fromCache:true,stale:cachedItem.isExpired()};}throw error;}}/**\n   * Effectue une requête POST (non mise en cache)\n   * @param {string} url URL de la requête\n   * @param {Object} data Données à envoyer\n   * @param {Object} config Configuration axios supplémentaire\n   * @returns {Promise<any>} Réponse de la requête\n   */async post(url,data){let config=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return this.axiosInstance.post(url,data,config).then(response=>response.data);}/**\n   * Effectue une requête PUT (non mise en cache)\n   * @param {string} url URL de la requête\n   * @param {Object} data Données à envoyer\n   * @param {Object} config Configuration axios supplémentaire\n   * @returns {Promise<any>} Réponse de la requête\n   */async put(url,data){let config=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return this.axiosInstance.put(url,data,config).then(response=>response.data);}/**\n   * Effectue une requête DELETE (non mise en cache)\n   * @param {string} url URL de la requête\n   * @param {Object} config Configuration axios supplémentaire\n   * @returns {Promise<any>} Réponse de la requête\n   */async delete(url){let config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return this.axiosInstance.delete(url,config).then(response=>response.data);}/**\n   * Effectue un appel réseau et met à jour le cache en arrière-plan\n   * @param {string} url URL de la requête\n   * @param {Object} params Paramètres de la requête\n   * @param {string} cacheKey Clé de cache\n   * @param {Object} cacheOptions Options de cache\n   * @returns {Promise<void>}\n   */async fetchFromNetworkAndUpdateCache(url,params,cacheKey,cacheOptions){try{const response=await this.fetchFromNetwork(url,params);this.cacheResponse(cacheKey,response,cacheOptions);}catch(error){console.error('Erreur lors de la mise à jour du cache en arrière-plan:',error);}}/**\n   * Effectue un appel réseau en gérant les requêtes en parallèle\n   * @param {string} url URL de la requête\n   * @param {Object} params Paramètres de la requête\n   * @returns {Promise<any>} Données de la réponse\n   */async fetchFromNetwork(url){let params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const cacheKey=this.generateCacheKey(url,params);// Vérifier si une requête identique est déjà en cours\nif(this.pendingRequests.has(cacheKey)){return this.pendingRequests.get(cacheKey);}// Créer une nouvelle promesse pour cette requête\nconst requestPromise=this.axiosInstance.get(url,{params}).then(response=>{// Capturer les headers ETag et Last-Modified\nconst headers=response.cacheHeaders||{};this.statistics.networkCalls++;this.pendingRequests.delete(cacheKey);return{data:response.data,headers,fromCache:false};}).catch(error=>{this.statistics.errors++;this.pendingRequests.delete(cacheKey);throw error;});// Enregistrer cette requête en cours\nthis.pendingRequests.set(cacheKey,requestPromise);return requestPromise;}/**\n   * Enregistre une réponse dans le cache\n   * @param {string} cacheKey Clé de cache\n   * @param {Object} response Réponse à mettre en cache\n   * @param {Object} options Options de cache\n   */cacheResponse(cacheKey,response){var _response$headers,_response$headers2;let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const{ttl=this.defaultTTL,tags=[]}=options;// Ne pas mettre en cache les réponses déjà issues du cache\nif(response.fromCache)return;// Créer un objet de cache\nconst cacheItem=new CacheItem(response.data,{ttl,tags,etag:(_response$headers=response.headers)===null||_response$headers===void 0?void 0:_response$headers.etag,lastModified:(_response$headers2=response.headers)===null||_response$headers2===void 0?void 0:_response$headers2.lastModified});// Ajouter au cache\nthis.cache.set(cacheKey,cacheItem);// Si le cache dépasse sa taille maximale, supprimer les entrées les plus anciennes\nif(this.cache.size>this.maxCacheSize){this.pruneCache();}// Persister dans le localStorage si nécessaire\nif(featureFlagsService.isEnabled('enableAdvancedCaching')){this.saveCacheToStorage();}}/**\n   * Réduit la taille du cache en supprimant les entrées les plus anciennes\n   */pruneCache(){if(this.cache.size<=this.maxCacheSize)return;const excess=this.cache.size-this.maxCacheSize;const entries=Array.from(this.cache.entries()).sort((a,b)=>a[1].timestamp-b[1].timestamp);for(let i=0;i<excess;i++){this.cache.delete(entries[i][0]);}}/**\n   * Invalide les entrées de cache pour une URL spécifique\n   * @param {string} url URL dont les entrées doivent être invalidées\n   * @param {Object} params Paramètres spécifiques (si null, toutes les entrées pour cette URL sont invalidées)\n   */invalidateCache(url){let params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(params===null){// Invalider toutes les entrées commençant par cette URL\nconst normalizedUrl=url.toLowerCase().trim();for(const key of this.cache.keys()){if(key.startsWith(normalizedUrl)){this.cache.delete(key);}}}else{// Invalider uniquement l'entrée spécifique\nconst cacheKey=this.generateCacheKey(url,params);this.cache.delete(cacheKey);}// Persister les changements\nif(featureFlagsService.isEnabled('enableAdvancedCaching')){this.saveCacheToStorage();}}/**\n   * Invalide les entrées de cache par tags\n   * @param {Array<string>} tags Liste des tags à invalider\n   */invalidateByTags(tags){if(!Array.isArray(tags)||tags.length===0)return;const keysToDelete=[];// Trouver toutes les entrées correspondant aux tags\nfor(const[key,item]of this.cache.entries()){const hasMatchingTag=tags.some(tag=>item.tags.includes(tag));if(hasMatchingTag){keysToDelete.push(key);}}// Supprimer les entrées trouvées\nkeysToDelete.forEach(key=>this.cache.delete(key));// Persister les changements\nif(keysToDelete.length>0&&featureFlagsService.isEnabled('enableAdvancedCaching')){this.saveCacheToStorage();}}/**\n   * Efface tout le cache\n   */clearCache(){this.cache.clear();localStorage.removeItem(this.storageKey);console.info('Cache API entièrement effacé');}/**\n   * Récupère les statistiques d'utilisation du cache\n   * @returns {Object} Statistiques d'utilisation\n   */getStatistics(){return{...this.statistics,cacheSize:this.cache.size,pendingRequests:this.pendingRequests.size};}/**\n   * Configure le service de cache\n   * @param {Object} config Configuration\n   */configure(){let config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(config.defaultTTL)this.defaultTTL=config.defaultTTL;if(config.maxCacheSize)this.maxCacheSize=config.maxCacheSize;if(config.defaultStrategy)this.defaultStrategy=config.defaultStrategy;console.info('Configuration du cache API mise à jour:',config);}/**\n   * Charge les configurations TTL depuis les feature flags\n   */async loadTTLConfigurations(){try{// Vérifier si la fonctionnalité de configuration TTL est activée\nconst configurationEnabled=featureFlagsService.isEnabled('enableConfigurableCacheTTL');if(configurationEnabled){// Récupérer le TTL global par défaut si configuré\nconst globalTTL=featureFlagsService.getValue('defaultCacheTTL');if(globalTTL&&typeof globalTTL==='number'&&globalTTL>0){this.defaultTTL=globalTTL*1000;// Conversion de secondes en millisecondes\nconsole.info(`TTL de cache global configuré à ${this.formatDuration(this.defaultTTL)}`);}// Récupérer les TTL spécifiques par catégorie\nconst categoryTTLs=featureFlagsService.getValue('categorySpecificTTLs')||{};for(const[category,ttl]of Object.entries(categoryTTLs)){if(typeof ttl==='number'&&ttl>0){this.categoryTTLs[category]=ttl*1000;// Conversion de secondes en millisecondes\nconsole.info(`TTL de cache pour la catégorie \"${category}\" configuré à ${this.formatDuration(ttl*1000)}`);}}// Sauvegarder la configuration pour référence\nlocalStorage.setItem(this.ttlConfigKey,JSON.stringify({defaultTTL:this.defaultTTL,categoryTTLs:this.categoryTTLs}));}else{// Si désactivé, utiliser les valeurs par défaut mais tenter de charger depuis le localStorage pour la persistance\nconst savedConfig=localStorage.getItem(this.ttlConfigKey);if(savedConfig){try{const{defaultTTL,categoryTTLs}=JSON.parse(savedConfig);this.defaultTTL=defaultTTL||this.defaultTTL;this.categoryTTLs=categoryTTLs||{};}catch(e){console.warn('Impossible de charger la configuration TTL sauvegardée:',e);}}}}catch(error){console.error('Erreur lors du chargement des configurations TTL:',error);}}/**\n   * Obtient le TTL approprié pour une URL donnée en se basant sur les catégories\n   * @param {string} url URL de la requête\n   * @param {Object} options Options de cache spécifiques à la requête\n   * @returns {number} TTL en millisecondes\n   */getTTLForUrl(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Si un TTL est explicitement défini dans les options, l'utiliser\nif(options.ttl&&typeof options.ttl==='number'){return options.ttl;}// Vérifier si l'URL correspond à une catégorie configurée\nconst normalizedUrl=url.toLowerCase();// Définir les catégories d'URL et leurs patterns\nconst urlCategories={'cols':/(\\/api\\/cols|\\/api\\/passes)/,'user':/\\/api\\/user/,'activities':/\\/api\\/activities/,'routes':/\\/api\\/routes/,'weather':/\\/api\\/weather/,'challenges':/\\/api\\/challenges/,'social':/\\/api\\/social/};// Vérifier si l'URL correspond à une catégorie ayant un TTL spécifique\nfor(const[category,pattern]of Object.entries(urlCategories)){if(pattern.test(normalizedUrl)&&this.categoryTTLs[category]){return this.categoryTTLs[category];}}// Utiliser le TTL par défaut\nreturn this.defaultTTL;}/**\n   * Formate une durée en millisecondes en chaîne de caractères lisible\n   * @param {number} ms Durée en millisecondes\n   * @returns {string} Durée formatée\n   */formatDuration(ms){if(ms<1000)return`${ms}ms`;if(ms<60000)return`${Math.round(ms/1000)}s`;if(ms<3600000)return`${Math.round(ms/60000)}m`;return`${Math.round(ms/3600000)}h`;}}// Créer une instance singleton du service\nconst apiCacheService=new ApiCacheService();// Exporter les constantes et le service\nexport{CACHE_STRATEGIES};export default apiCacheService;","map":{"version":3,"names":["axios","featureFlagsService","CACHE_STRATEGIES","NETWORK_FIRST","CACHE_FIRST","STALE_WHILE_REVALIDATE","NETWORK_ONLY","CACHE_ONLY","CacheItem","constructor","data","params","arguments","length","undefined","timestamp","Date","now","expiry","ttl","staleExpiry","staleTime","tags","etag","lastModified","isExpired","isStale","extend","additionalTime","ApiCacheService","cache","Map","pendingRequests","isInitialized","storageKey","defaultTTL","maxCacheSize","defaultStrategy","networkMonitor","isOnline","lastCheck","statistics","hits","misses","errors","networkCalls","ttlConfigKey","categoryTTLs","axiosInstance","create","timeout","interceptors","request","use","config","cacheKey","generateCacheKey","url","cachedItem","get","headers","response","newHeaders","cacheHeaders","error","status","statusText","fromCache","set","Promise","reject","initialize","loadTTLConfigurations","isEnabled","loadCacheFromStorage","setupNetworkMonitoring","setupPeriodicCleanup","console","info","cacheSize","size","formatDuration","window","addEventListener","navigator","onLine","CLEANUP_INTERVAL","setInterval","cleanupCache","deleteCount","key","item","entries","delete","excess","Array","from","sort","a","b","i","saveCacheToStorage","storedCache","localStorage","getItem","parsedCache","JSON","parse","validEntries","Object","forEach","_ref","value","cacheItem","clear","cacheObject","setItem","stringify","normalizedUrl","toLowerCase","trim","sortedParams","keys","options","strategy","getTTLForUrl","cacheOptions","isCachingEnabled","fetchFromNetwork","Error","cacheResponse","warn","stale","fetchFromNetworkAndUpdateCache","catch","post","then","put","has","requestPromise","_response$headers","_response$headers2","pruneCache","invalidateCache","startsWith","invalidateByTags","isArray","keysToDelete","hasMatchingTag","some","tag","includes","push","clearCache","removeItem","getStatistics","configure","configurationEnabled","globalTTL","getValue","category","savedConfig","e","urlCategories","pattern","test","ms","Math","round","apiCacheService"],"sources":["C:/Users/busin/CascadeProjects/grand-est-cyclisme-website-final (1) VERSION FINAL/client/src/services/apiCache.js"],"sourcesContent":["/**\n * Service de cache API avancé\n * Permet de réduire les appels API redondants et d'améliorer les performances\n * Supporte plusieurs stratégies de cache, invalidation intelligente et persistance\n */\nimport axios from 'axios';\nimport featureFlagsService from './featureFlags';\n\n// Constantes pour les stratégies de cache\nconst CACHE_STRATEGIES = {\n  NETWORK_FIRST: 'network-first',  // Essaie le réseau, utilise le cache en fallback\n  CACHE_FIRST: 'cache-first',      // Utilise le cache, fait appel au réseau si expiré ou absent\n  STALE_WHILE_REVALIDATE: 'stale-while-revalidate', // Retourne le cache immédiatement et met à jour en arrière-plan\n  NETWORK_ONLY: 'network-only',    // Toujours utiliser le réseau (désactive le cache)\n  CACHE_ONLY: 'cache-only'         // Toujours utiliser le cache (mode hors ligne)\n};\n\n// Structure de l'élément de cache\nclass CacheItem {\n  constructor(data, params = {}) {\n    this.data = data;\n    this.timestamp = Date.now();\n    this.expiry = this.timestamp + (params.ttl || 5 * 60 * 1000); // 5 minutes par défaut\n    this.staleExpiry = this.expiry + (params.staleTime || 60 * 60 * 1000); // 1 heure de plus pour les données obsolètes\n    this.tags = params.tags || [];\n    this.etag = params.etag || null;\n    this.lastModified = params.lastModified || null;\n  }\n\n  isExpired() {\n    return Date.now() > this.expiry;\n  }\n\n  isStale() {\n    return this.isExpired() && Date.now() <= this.staleExpiry;\n  }\n\n  // Méthode pour étendre la durée de vie du cache\n  extend(additionalTime) {\n    this.expiry += additionalTime;\n    this.staleExpiry += additionalTime;\n  }\n}\n\n/**\n * Service principal de gestion du cache API\n */\nclass ApiCacheService {\n  constructor() {\n    this.cache = new Map();\n    this.pendingRequests = new Map();\n    this.isInitialized = false;\n    this.storageKey = 'api_cache_data';\n    this.defaultTTL = 5 * 60 * 1000; // 5 minutes par défaut\n    this.maxCacheSize = 100; // Nombre maximum d'entrées dans le cache\n    this.defaultStrategy = CACHE_STRATEGIES.CACHE_FIRST;\n    this.networkMonitor = {\n      isOnline: true,\n      lastCheck: Date.now()\n    };\n    this.statistics = {\n      hits: 0,\n      misses: 0,\n      errors: 0,\n      networkCalls: 0\n    };\n    this.ttlConfigKey = 'api_cache_ttl_config';\n    this.categoryTTLs = {};\n\n    // Création d'une instance axios personnalisée\n    this.axiosInstance = axios.create({\n      timeout: 10000, // 10 secondes de timeout par défaut\n    });\n\n    // Intercepteur pour ajouter les headers de cache\n    this.axiosInstance.interceptors.request.use(config => {\n      const cacheKey = this.generateCacheKey(config.url, config.params);\n      \n      // Ajouter les headers conditionnels si disponibles\n      const cachedItem = this.cache.get(cacheKey);\n      if (cachedItem) {\n        if (cachedItem.etag) {\n          config.headers['If-None-Match'] = cachedItem.etag;\n        }\n        if (cachedItem.lastModified) {\n          config.headers['If-Modified-Since'] = cachedItem.lastModified;\n        }\n      }\n      \n      return config;\n    });\n\n    // Intercepteur pour gérer les réponses 304 Not Modified\n    this.axiosInstance.interceptors.response.use(\n      response => {\n        // Capture des headers ETag et Last-Modified\n        const newHeaders = {};\n        if (response.headers.etag) {\n          newHeaders.etag = response.headers.etag;\n        }\n        if (response.headers['last-modified']) {\n          newHeaders.lastModified = response.headers['last-modified'];\n        }\n        \n        // Ajouter les headers à la réponse pour utilisation dans le cache\n        response.cacheHeaders = newHeaders;\n        return response;\n      },\n      error => {\n        // Si 304 Not Modified, considérer comme un succès\n        if (error.response && error.response.status === 304) {\n          const cacheKey = this.generateCacheKey(\n            error.config.url, \n            error.config.params\n          );\n          const cachedItem = this.cache.get(cacheKey);\n          \n          if (cachedItem) {\n            // Créer une réponse simulée avec les données du cache\n            const response = {\n              data: cachedItem.data,\n              status: 200,\n              statusText: 'OK (from cache)',\n              headers: error.response.headers,\n              config: error.config,\n              fromCache: true\n            };\n            \n            // Prolonger la durée de vie du cache\n            cachedItem.extend(this.defaultTTL);\n            this.cache.set(cacheKey, cachedItem);\n            \n            return response;\n          }\n        }\n        \n        return Promise.reject(error);\n      }\n    );\n  }\n\n  /**\n   * Initialise le service de cache\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n    \n    try {\n      // Charger les TTL spécifiques par catégorie depuis les feature flags\n      await this.loadTTLConfigurations();\n      \n      // Si le caching avancé est activé, charger depuis le stockage\n      if (featureFlagsService.isEnabled('enableAdvancedCaching')) {\n        await this.loadCacheFromStorage();\n      }\n      \n      // Configurer la surveillance réseau\n      this.setupNetworkMonitoring();\n      \n      // Configurer le nettoyage périodique du cache\n      this.setupPeriodicCleanup();\n      \n      this.isInitialized = true;\n      console.info('Service de cache API initialisé', {\n        cacheSize: this.cache.size,\n        defaultTTL: this.formatDuration(this.defaultTTL)\n      });\n    } catch (error) {\n      console.error('Erreur lors de l\\'initialisation du cache API:', error);\n    }\n  }\n\n  /**\n   * Configure la surveillance de la connexion réseau\n   */\n  setupNetworkMonitoring() {\n    if (typeof window !== 'undefined') {\n      // Détecter les changements de connectivité\n      window.addEventListener('online', () => {\n        this.networkMonitor.isOnline = true;\n        this.networkMonitor.lastCheck = Date.now();\n        console.info('Connectivité rétablie - API Cache passe en mode en ligne');\n      });\n      \n      window.addEventListener('offline', () => {\n        this.networkMonitor.isOnline = false;\n        this.networkMonitor.lastCheck = Date.now();\n        console.info('Connectivité perdue - API Cache passe en mode hors ligne');\n      });\n      \n      // État initial\n      this.networkMonitor.isOnline = navigator.onLine;\n    }\n  }\n\n  /**\n   * Configure le nettoyage périodique du cache\n   */\n  setupPeriodicCleanup() {\n    // Nettoyer toutes les heures\n    const CLEANUP_INTERVAL = 60 * 60 * 1000;\n    \n    if (typeof window !== 'undefined') {\n      setInterval(() => this.cleanupCache(), CLEANUP_INTERVAL);\n    }\n  }\n\n  /**\n   * Nettoie le cache en supprimant les entrées expirées et en respectant la taille maximale\n   */\n  cleanupCache() {\n    if (this.cache.size === 0) return;\n    \n    console.info('Nettoyage du cache API en cours...');\n    const now = Date.now();\n    let deleteCount = 0;\n    \n    // Supprimer les entrées complètement expirées (même stale)\n    for (const [key, item] of this.cache.entries()) {\n      if (now > item.staleExpiry) {\n        this.cache.delete(key);\n        deleteCount++;\n      }\n    }\n    \n    // Si le cache est toujours trop grand, supprimer les entrées les plus anciennes\n    if (this.cache.size > this.maxCacheSize) {\n      const excess = this.cache.size - this.maxCacheSize;\n      const entries = Array.from(this.cache.entries())\n        .sort((a, b) => a[1].timestamp - b[1].timestamp);\n      \n      for (let i = 0; i < excess; i++) {\n        this.cache.delete(entries[i][0]);\n        deleteCount++;\n      }\n    }\n    \n    console.info(`Nettoyage du cache terminé: ${deleteCount} entrées supprimées`);\n    this.saveCacheToStorage();\n  }\n\n  /**\n   * Charge le cache depuis le localStorage\n   */\n  async loadCacheFromStorage() {\n    try {\n      const storedCache = localStorage.getItem(this.storageKey);\n      if (!storedCache) return;\n      \n      const parsedCache = JSON.parse(storedCache);\n      const now = Date.now();\n      let validEntries = 0;\n      \n      // Ne charger que les entrées non complètement expirées\n      Object.entries(parsedCache).forEach(([key, value]) => {\n        // Recréer l'objet CacheItem correctement avec ses méthodes\n        const cacheItem = new CacheItem(value.data, {\n          ttl: value.expiry - value.timestamp,\n          staleTime: value.staleExpiry - value.expiry,\n          tags: value.tags,\n          etag: value.etag,\n          lastModified: value.lastModified\n        });\n        \n        // Restaurer les timestamps originaux\n        cacheItem.timestamp = value.timestamp;\n        cacheItem.expiry = value.expiry;\n        cacheItem.staleExpiry = value.staleExpiry;\n        \n        // Ne pas charger les entrées complètement expirées\n        if (now <= cacheItem.staleExpiry) {\n          this.cache.set(key, cacheItem);\n          validEntries++;\n        }\n      });\n      \n      console.info(`Cache chargé depuis le localStorage: ${validEntries} entrées valides`);\n    } catch (error) {\n      console.error('Erreur lors du chargement du cache depuis le localStorage:', error);\n      // Si erreur, démarrer avec un cache vide\n      this.cache.clear();\n    }\n  }\n\n  /**\n   * Sauvegarde le cache dans le localStorage\n   */\n  saveCacheToStorage() {\n    try {\n      // Convertir le Map en objet pour le stockage\n      const cacheObject = {};\n      \n      for (const [key, value] of this.cache.entries()) {\n        cacheObject[key] = {\n          data: value.data,\n          timestamp: value.timestamp,\n          expiry: value.expiry,\n          staleExpiry: value.staleExpiry,\n          tags: value.tags,\n          etag: value.etag,\n          lastModified: value.lastModified\n        };\n      }\n      \n      localStorage.setItem(this.storageKey, JSON.stringify(cacheObject));\n    } catch (error) {\n      console.error('Erreur lors de la sauvegarde du cache dans le localStorage:', error);\n    }\n  }\n\n  /**\n   * Génère une clé de cache unique pour une URL et des paramètres\n   * @param {string} url URL de la requête\n   * @param {Object} params Paramètres de la requête\n   * @returns {string} Clé de cache unique\n   */\n  generateCacheKey(url, params = {}) {\n    // Normaliser l'URL\n    const normalizedUrl = url.toLowerCase().trim();\n    \n    // Trier les paramètres pour assurer la cohérence des clés\n    const sortedParams = {};\n    if (params) {\n      Object.keys(params).sort().forEach(key => {\n        sortedParams[key] = params[key];\n      });\n    }\n    \n    // Créer une clé unique\n    return `${normalizedUrl}|${JSON.stringify(sortedParams)}`;\n  }\n\n  /**\n   * Effectue une requête GET avec gestion de cache\n   * @param {string} url URL de la requête\n   * @param {Object} options Options de la requête\n   * @param {Object} options.params Paramètres de la requête\n   * @param {string} options.strategy Stratégie de cache à utiliser\n   * @param {number} options.ttl Durée de vie du cache en millisecondes\n   * @param {Array<string>} options.tags Tags associés à cette entrée de cache\n   * @returns {Promise<any>} Données de la réponse\n   */\n  async get(url, options = {}) {\n    // Initialiser le service si ce n'est pas déjà fait\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n    \n    const {\n      params = {},\n      strategy = this.defaultStrategy,\n      tags = []\n    } = options;\n    \n    // Utiliser le TTL approprié pour cette URL\n    const ttl = this.getTTLForUrl(url, options);\n    \n    // Créer la clé de cache\n    const cacheKey = this.generateCacheKey(url, params);\n    \n    // Vérifier si la réponse est en cache\n    const cachedItem = this.cache.get(cacheKey);\n    \n    // Options de cache à utiliser pour la mise en cache\n    const cacheOptions = { ttl, tags };\n    \n    // Vérifier si le caching est activé\n    const isCachingEnabled = featureFlagsService.isEnabled('enableApiCaching');\n    \n    // Si le caching est désactivé, faire un appel réseau direct\n    if (!isCachingEnabled || strategy === CACHE_STRATEGIES.NETWORK_ONLY) {\n      return this.fetchFromNetwork(url, params);\n    }\n    \n    // Gestion du mode hors ligne forcé\n    if (strategy === CACHE_STRATEGIES.CACHE_ONLY) {\n      if (cachedItem) {\n        this.statistics.hits++;\n        return { ...cachedItem.data, fromCache: true };\n      } else {\n        this.statistics.misses++;\n        throw new Error('Aucune donnée en cache et mode CACHE_ONLY activé');\n      }\n    }\n    \n    // Gestion du mode hors ligne en cas de perte de connectivité\n    if (!this.networkMonitor.isOnline) {\n      if (cachedItem) {\n        console.info('Mode hors ligne - Utilisation du cache pour:', url);\n        return { ...cachedItem.data, fromCache: true };\n      } else {\n        throw new Error('Aucune donnée en cache et appareil hors ligne');\n      }\n    }\n    \n    // Stratégie CACHE_FIRST\n    if (strategy === CACHE_STRATEGIES.CACHE_FIRST) {\n      if (cachedItem && !cachedItem.isExpired()) {\n        this.statistics.hits++;\n        return { ...cachedItem.data, fromCache: true };\n      }\n      \n      // Cache expiré ou absent\n      try {\n        const response = await this.fetchFromNetwork(url, params);\n        this.cacheResponse(cacheKey, response, cacheOptions);\n        return response;\n      } catch (error) {\n        // En cas d'erreur réseau, utiliser le cache même expiré si disponible\n        if (cachedItem) {\n          console.warn('Erreur réseau - Utilisation du cache expiré pour:', url);\n          return { ...cachedItem.data, fromCache: true, stale: true };\n        }\n        throw error;\n      }\n    }\n    \n    // Stratégie STALE_WHILE_REVALIDATE\n    if (strategy === CACHE_STRATEGIES.STALE_WHILE_REVALIDATE) {\n      // Si un élément est en cache, le retourner immédiatement\n      if (cachedItem) {\n        // Mettre à jour en arrière-plan si expiré\n        if (cachedItem.isExpired()) {\n          this.fetchFromNetworkAndUpdateCache(url, params, cacheKey, cacheOptions)\n            .catch(error => console.error('Erreur lors de la mise à jour du cache en arrière-plan:', error));\n        }\n        \n        this.statistics.hits++;\n        return { ...cachedItem.data, fromCache: true, stale: cachedItem.isExpired() };\n      }\n      \n      // Rien en cache, faire un appel réseau\n      const response = await this.fetchFromNetwork(url, params);\n      this.cacheResponse(cacheKey, response, cacheOptions);\n      return response;\n    }\n    \n    // Par défaut: NETWORK_FIRST\n    try {\n      const response = await this.fetchFromNetwork(url, params);\n      this.cacheResponse(cacheKey, response, cacheOptions);\n      return response;\n    } catch (error) {\n      // En cas d'erreur réseau, utiliser le cache si disponible\n      if (cachedItem) {\n        console.warn('Erreur réseau - Utilisation du cache pour:', url);\n        this.statistics.hits++;\n        return { ...cachedItem.data, fromCache: true, stale: cachedItem.isExpired() };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Effectue une requête POST (non mise en cache)\n   * @param {string} url URL de la requête\n   * @param {Object} data Données à envoyer\n   * @param {Object} config Configuration axios supplémentaire\n   * @returns {Promise<any>} Réponse de la requête\n   */\n  async post(url, data, config = {}) {\n    return this.axiosInstance.post(url, data, config).then(response => response.data);\n  }\n\n  /**\n   * Effectue une requête PUT (non mise en cache)\n   * @param {string} url URL de la requête\n   * @param {Object} data Données à envoyer\n   * @param {Object} config Configuration axios supplémentaire\n   * @returns {Promise<any>} Réponse de la requête\n   */\n  async put(url, data, config = {}) {\n    return this.axiosInstance.put(url, data, config).then(response => response.data);\n  }\n\n  /**\n   * Effectue une requête DELETE (non mise en cache)\n   * @param {string} url URL de la requête\n   * @param {Object} config Configuration axios supplémentaire\n   * @returns {Promise<any>} Réponse de la requête\n   */\n  async delete(url, config = {}) {\n    return this.axiosInstance.delete(url, config).then(response => response.data);\n  }\n\n  /**\n   * Effectue un appel réseau et met à jour le cache en arrière-plan\n   * @param {string} url URL de la requête\n   * @param {Object} params Paramètres de la requête\n   * @param {string} cacheKey Clé de cache\n   * @param {Object} cacheOptions Options de cache\n   * @returns {Promise<void>}\n   */\n  async fetchFromNetworkAndUpdateCache(url, params, cacheKey, cacheOptions) {\n    try {\n      const response = await this.fetchFromNetwork(url, params);\n      this.cacheResponse(cacheKey, response, cacheOptions);\n    } catch (error) {\n      console.error('Erreur lors de la mise à jour du cache en arrière-plan:', error);\n    }\n  }\n\n  /**\n   * Effectue un appel réseau en gérant les requêtes en parallèle\n   * @param {string} url URL de la requête\n   * @param {Object} params Paramètres de la requête\n   * @returns {Promise<any>} Données de la réponse\n   */\n  async fetchFromNetwork(url, params = {}) {\n    const cacheKey = this.generateCacheKey(url, params);\n    \n    // Vérifier si une requête identique est déjà en cours\n    if (this.pendingRequests.has(cacheKey)) {\n      return this.pendingRequests.get(cacheKey);\n    }\n    \n    // Créer une nouvelle promesse pour cette requête\n    const requestPromise = this.axiosInstance.get(url, { params })\n      .then(response => {\n        // Capturer les headers ETag et Last-Modified\n        const headers = response.cacheHeaders || {};\n        \n        this.statistics.networkCalls++;\n        this.pendingRequests.delete(cacheKey);\n        return {\n          data: response.data,\n          headers,\n          fromCache: false\n        };\n      })\n      .catch(error => {\n        this.statistics.errors++;\n        this.pendingRequests.delete(cacheKey);\n        throw error;\n      });\n    \n    // Enregistrer cette requête en cours\n    this.pendingRequests.set(cacheKey, requestPromise);\n    \n    return requestPromise;\n  }\n\n  /**\n   * Enregistre une réponse dans le cache\n   * @param {string} cacheKey Clé de cache\n   * @param {Object} response Réponse à mettre en cache\n   * @param {Object} options Options de cache\n   */\n  cacheResponse(cacheKey, response, options = {}) {\n    const { ttl = this.defaultTTL, tags = [] } = options;\n    \n    // Ne pas mettre en cache les réponses déjà issues du cache\n    if (response.fromCache) return;\n    \n    // Créer un objet de cache\n    const cacheItem = new CacheItem(response.data, {\n      ttl,\n      tags,\n      etag: response.headers?.etag,\n      lastModified: response.headers?.lastModified\n    });\n    \n    // Ajouter au cache\n    this.cache.set(cacheKey, cacheItem);\n    \n    // Si le cache dépasse sa taille maximale, supprimer les entrées les plus anciennes\n    if (this.cache.size > this.maxCacheSize) {\n      this.pruneCache();\n    }\n    \n    // Persister dans le localStorage si nécessaire\n    if (featureFlagsService.isEnabled('enableAdvancedCaching')) {\n      this.saveCacheToStorage();\n    }\n  }\n\n  /**\n   * Réduit la taille du cache en supprimant les entrées les plus anciennes\n   */\n  pruneCache() {\n    if (this.cache.size <= this.maxCacheSize) return;\n    \n    const excess = this.cache.size - this.maxCacheSize;\n    const entries = Array.from(this.cache.entries())\n      .sort((a, b) => a[1].timestamp - b[1].timestamp);\n    \n    for (let i = 0; i < excess; i++) {\n      this.cache.delete(entries[i][0]);\n    }\n  }\n\n  /**\n   * Invalide les entrées de cache pour une URL spécifique\n   * @param {string} url URL dont les entrées doivent être invalidées\n   * @param {Object} params Paramètres spécifiques (si null, toutes les entrées pour cette URL sont invalidées)\n   */\n  invalidateCache(url, params = null) {\n    if (params === null) {\n      // Invalider toutes les entrées commençant par cette URL\n      const normalizedUrl = url.toLowerCase().trim();\n      \n      for (const key of this.cache.keys()) {\n        if (key.startsWith(normalizedUrl)) {\n          this.cache.delete(key);\n        }\n      }\n    } else {\n      // Invalider uniquement l'entrée spécifique\n      const cacheKey = this.generateCacheKey(url, params);\n      this.cache.delete(cacheKey);\n    }\n    \n    // Persister les changements\n    if (featureFlagsService.isEnabled('enableAdvancedCaching')) {\n      this.saveCacheToStorage();\n    }\n  }\n\n  /**\n   * Invalide les entrées de cache par tags\n   * @param {Array<string>} tags Liste des tags à invalider\n   */\n  invalidateByTags(tags) {\n    if (!Array.isArray(tags) || tags.length === 0) return;\n    \n    const keysToDelete = [];\n    \n    // Trouver toutes les entrées correspondant aux tags\n    for (const [key, item] of this.cache.entries()) {\n      const hasMatchingTag = tags.some(tag => item.tags.includes(tag));\n      if (hasMatchingTag) {\n        keysToDelete.push(key);\n      }\n    }\n    \n    // Supprimer les entrées trouvées\n    keysToDelete.forEach(key => this.cache.delete(key));\n    \n    // Persister les changements\n    if (keysToDelete.length > 0 && featureFlagsService.isEnabled('enableAdvancedCaching')) {\n      this.saveCacheToStorage();\n    }\n  }\n\n  /**\n   * Efface tout le cache\n   */\n  clearCache() {\n    this.cache.clear();\n    localStorage.removeItem(this.storageKey);\n    console.info('Cache API entièrement effacé');\n  }\n\n  /**\n   * Récupère les statistiques d'utilisation du cache\n   * @returns {Object} Statistiques d'utilisation\n   */\n  getStatistics() {\n    return {\n      ...this.statistics,\n      cacheSize: this.cache.size,\n      pendingRequests: this.pendingRequests.size\n    };\n  }\n\n  /**\n   * Configure le service de cache\n   * @param {Object} config Configuration\n   */\n  configure(config = {}) {\n    if (config.defaultTTL) this.defaultTTL = config.defaultTTL;\n    if (config.maxCacheSize) this.maxCacheSize = config.maxCacheSize;\n    if (config.defaultStrategy) this.defaultStrategy = config.defaultStrategy;\n    \n    console.info('Configuration du cache API mise à jour:', config);\n  }\n\n  /**\n   * Charge les configurations TTL depuis les feature flags\n   */\n  async loadTTLConfigurations() {\n    try {\n      // Vérifier si la fonctionnalité de configuration TTL est activée\n      const configurationEnabled = featureFlagsService.isEnabled('enableConfigurableCacheTTL');\n      \n      if (configurationEnabled) {\n        // Récupérer le TTL global par défaut si configuré\n        const globalTTL = featureFlagsService.getValue('defaultCacheTTL');\n        if (globalTTL && typeof globalTTL === 'number' && globalTTL > 0) {\n          this.defaultTTL = globalTTL * 1000; // Conversion de secondes en millisecondes\n          console.info(`TTL de cache global configuré à ${this.formatDuration(this.defaultTTL)}`);\n        }\n        \n        // Récupérer les TTL spécifiques par catégorie\n        const categoryTTLs = featureFlagsService.getValue('categorySpecificTTLs') || {};\n        \n        for (const [category, ttl] of Object.entries(categoryTTLs)) {\n          if (typeof ttl === 'number' && ttl > 0) {\n            this.categoryTTLs[category] = ttl * 1000; // Conversion de secondes en millisecondes\n            console.info(`TTL de cache pour la catégorie \"${category}\" configuré à ${this.formatDuration(ttl * 1000)}`);\n          }\n        }\n        \n        // Sauvegarder la configuration pour référence\n        localStorage.setItem(this.ttlConfigKey, JSON.stringify({\n          defaultTTL: this.defaultTTL,\n          categoryTTLs: this.categoryTTLs\n        }));\n      } else {\n        // Si désactivé, utiliser les valeurs par défaut mais tenter de charger depuis le localStorage pour la persistance\n        const savedConfig = localStorage.getItem(this.ttlConfigKey);\n        if (savedConfig) {\n          try {\n            const { defaultTTL, categoryTTLs } = JSON.parse(savedConfig);\n            this.defaultTTL = defaultTTL || this.defaultTTL;\n            this.categoryTTLs = categoryTTLs || {};\n          } catch (e) {\n            console.warn('Impossible de charger la configuration TTL sauvegardée:', e);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Erreur lors du chargement des configurations TTL:', error);\n    }\n  }\n\n  /**\n   * Obtient le TTL approprié pour une URL donnée en se basant sur les catégories\n   * @param {string} url URL de la requête\n   * @param {Object} options Options de cache spécifiques à la requête\n   * @returns {number} TTL en millisecondes\n   */\n  getTTLForUrl(url, options = {}) {\n    // Si un TTL est explicitement défini dans les options, l'utiliser\n    if (options.ttl && typeof options.ttl === 'number') {\n      return options.ttl;\n    }\n    \n    // Vérifier si l'URL correspond à une catégorie configurée\n    const normalizedUrl = url.toLowerCase();\n    \n    // Définir les catégories d'URL et leurs patterns\n    const urlCategories = {\n      'cols': /(\\/api\\/cols|\\/api\\/passes)/,\n      'user': /\\/api\\/user/,\n      'activities': /\\/api\\/activities/,\n      'routes': /\\/api\\/routes/,\n      'weather': /\\/api\\/weather/,\n      'challenges': /\\/api\\/challenges/,\n      'social': /\\/api\\/social/\n    };\n    \n    // Vérifier si l'URL correspond à une catégorie ayant un TTL spécifique\n    for (const [category, pattern] of Object.entries(urlCategories)) {\n      if (pattern.test(normalizedUrl) && this.categoryTTLs[category]) {\n        return this.categoryTTLs[category];\n      }\n    }\n    \n    // Utiliser le TTL par défaut\n    return this.defaultTTL;\n  }\n\n  /**\n   * Formate une durée en millisecondes en chaîne de caractères lisible\n   * @param {number} ms Durée en millisecondes\n   * @returns {string} Durée formatée\n   */\n  formatDuration(ms) {\n    if (ms < 1000) return `${ms}ms`;\n    if (ms < 60000) return `${Math.round(ms / 1000)}s`;\n    if (ms < 3600000) return `${Math.round(ms / 60000)}m`;\n    return `${Math.round(ms / 3600000)}h`;\n  }\n}\n\n// Créer une instance singleton du service\nconst apiCacheService = new ApiCacheService();\n\n// Exporter les constantes et le service\nexport { CACHE_STRATEGIES };\nexport default apiCacheService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}