/**
 * Utilitaire pour tester le syst√®me de feature flags
 * Permet de v√©rifier le fonctionnement de la segmentation utilisateur et des overrides
 */

// Configuration des tests
const TEST_CONFIG = {
  testCases: [
    {
      name: 'Test des flags de base',
      flags: ['progressiveLoading', 'apiCaching', 'optimized3DViz', 'timeoutRetryStrategy']
    },
    {
      name: 'Test de segmentation utilisateur',
      roles: ['anonymous', 'user', 'premium', 'admin'],
      flags: ['premiumFeatures', 'adminDashboard', 'betaFeatures']
    },
    {
      name: 'Test des variantes',
      variants: ['qualityLevel', 'uiDensity', 'colorScheme']
    },
    {
      name: 'Test des contraintes temporelles',
      flags: ['seasonalFeature', 'specialEvent', 'limitedTimeOffer']
    },
    {
      name: 'Test sp√©cifique pour SevenMajorsChallenge',
      flags: ['sevenMajorsChallenge', 'advancedFiltering', '3DColVisualization', 'challengeRecommendations']
    }
  ],
  
  // Les utilisateurs de test pour v√©rifier la segmentation
  testUsers: {
    anonymous: { id: null, role: 'anonymous', preferences: {} },
    basicUser: { id: 'user123', role: 'user', preferences: { theme: 'light', notifications: true } },
    premiumUser: { id: 'premium456', role: 'premium', preferences: { theme: 'dark', notifications: true } },
    adminUser: { id: 'admin789', role: 'admin', preferences: { theme: 'system', notifications: false } }
  }
};

// R√©sultats des tests
let testResults = {
  flagsBasic: {},
  segmentation: {},
  variants: {},
  temporalConstraints: {},
  overrides: {},
  persistence: {},
  specificFeatures: {},
  timestamp: new Date().toISOString()
};

/**
 * Ex√©cute les tests de base sur les feature flags
 * @returns {Object} R√©sultats des tests
 */
export function runBasicFlagsTests() {
  console.log('üîç Ex√©cution des tests de base sur les feature flags...');
  
  const results = {};
  
  // V√©rifier l'acc√®s au service
  if (!window.featureFlagsService) {
    console.error('‚ùå Service de feature flags non disponible');
    return { error: 'Service non disponible' };
  }
  
  // R√©cup√©rer tous les flags
  const allFlags = window.featureFlagsService.getAll();
  console.log('üìã Liste de tous les flags:', allFlags);
  results.allFlags = allFlags;
  
  // Tester chaque flag de base
  for (const flag of TEST_CONFIG.testCases[0].flags) {
    try {
      const isEnabled = window.featureFlagsService.isEnabled(flag);
      console.log(`üö© ${flag}: ${isEnabled ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©'}`);
      results[flag] = { enabled: isEnabled, success: true };
    } catch (error) {
      console.error(`‚ùå Erreur lors du test du flag ${flag}:`, error);
      results[flag] = { error: error.message, success: false };
    }
  }
  
  testResults.flagsBasic = results;
  console.log('‚úÖ Tests de base termin√©s');
  
  return results;
}

/**
 * Ex√©cute les tests de segmentation utilisateur
 * @returns {Object} R√©sultats des tests
 */
export function runSegmentationTests() {
  console.log('üîç Ex√©cution des tests de segmentation utilisateur...');
  
  const results = {
    byRole: {}
  };
  
  // Tester chaque r√¥le utilisateur
  for (const role of TEST_CONFIG.testCases[1].roles) {
    results.byRole[role] = {};
    
    // Simuler l'utilisateur actuel
    const testUser = TEST_CONFIG.testUsers[role === 'anonymous' ? 'anonymous' : 
                                          role === 'admin' ? 'adminUser' : 
                                          role === 'premium' ? 'premiumUser' : 'basicUser'];
    
    // Appliquer temporairement l'utilisateur de test
    const originalUser = window.featureFlagsService.getCurrentUser();
    window.featureFlagsService.setCurrentUser(testUser);
    
    // Tester chaque flag avec cet utilisateur
    for (const flag of TEST_CONFIG.testCases[1].flags) {
      try {
        const isEnabled = window.featureFlagsService.isEnabled(flag);
        console.log(`üë§ Utilisateur ${role} - Flag ${flag}: ${isEnabled ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©'}`);
        results.byRole[role][flag] = { enabled: isEnabled, success: true };
      } catch (error) {
        console.error(`‚ùå Erreur lors du test du flag ${flag} pour ${role}:`, error);
        results.byRole[role][flag] = { error: error.message, success: false };
      }
    }
    
    // R√©cup√©rer les flags √©ligibles pour ce r√¥le
    try {
      const eligibleFlags = window.featureFlagsService.getEligibleFlags();
      results.byRole[role].eligibleFlags = eligibleFlags;
    } catch (error) {
      console.error(`‚ùå Erreur lors de la r√©cup√©ration des flags √©ligibles pour ${role}:`, error);
      results.byRole[role].eligibleFlags = { error: error.message };
    }
    
    // Restaurer l'utilisateur original
    window.featureFlagsService.setCurrentUser(originalUser);
  }
  
  testResults.segmentation = results;
  console.log('‚úÖ Tests de segmentation termin√©s');
  
  return results;
}

/**
 * Ex√©cute les tests de variantes de feature flags
 * @returns {Object} R√©sultats des tests
 */
export function runVariantTests() {
  console.log('üîç Ex√©cution des tests de variantes...');
  
  const results = {};
  
  // Tester chaque variante
  for (const variant of TEST_CONFIG.testCases[2].variants) {
    try {
      const value = window.featureFlagsService.getVariant(variant);
      console.log(`üîÑ Variante ${variant}: ${value}`);
      results[variant] = { value, success: true };
      
      // Tester l'override de variante
      const testValue = Array.isArray(value) ? 
        (value.length > 1 ? value[1] : 'test-value') : 
        (typeof value === 'string' ? value + '-test' : 'test-value');
      
      window.featureFlagsService.overrideVariant(variant, testValue);
      const overriddenValue = window.featureFlagsService.getVariant(variant);
      
      results[variant].override = {
        appliedValue: testValue,
        actualValue: overriddenValue,
        success: overriddenValue === testValue
      };
      
      // R√©initialiser la variante
      window.featureFlagsService.resetVariantOverride(variant);
      
    } catch (error) {
      console.error(`‚ùå Erreur lors du test de la variante ${variant}:`, error);
      results[variant] = { error: error.message, success: false };
    }
  }
  
  testResults.variants = results;
  console.log('‚úÖ Tests de variantes termin√©s');
  
  return results;
}

/**
 * Ex√©cute les tests d'override et persistance
 * @returns {Object} R√©sultats des tests
 */
export function runOverrideTests() {
  console.log('üîç Ex√©cution des tests d\'override...');
  
  const results = {
    override: {},
    persistence: {}
  };
  
  // S√©lectionner quelques flags pour les tests
  const testFlags = TEST_CONFIG.testCases[0].flags.slice(0, 2);
  
  // Enregistrer l'√©tat initial
  const initialStates = {};
  for (const flag of testFlags) {
    initialStates[flag] = window.featureFlagsService.isEnabled(flag);
  }
  
  // Tester les overrides
  for (const flag of testFlags) {
    const newState = !initialStates[flag];
    
    try {
      window.featureFlagsService.override(flag, newState);
      const overriddenState = window.featureFlagsService.isEnabled(flag);
      
      console.log(`üîÑ Override ${flag} √† ${newState}: ${overriddenState === newState ? '‚úÖ R√©ussi' : '‚ùå √âchou√©'}`);
      results.override[flag] = { 
        initialState: initialStates[flag],
        overrideValue: newState,
        actualValue: overriddenState,
        success: overriddenState === newState
      };
    } catch (error) {
      console.error(`‚ùå Erreur lors de l'override du flag ${flag}:`, error);
      results.override[flag] = { error: error.message, success: false };
    }
  }
  
  // Tester la persistance (apr√®s un rechargement simul√©)
  console.log('üîÑ Simulation de rechargement pour tester la persistance...');
  
  // Au lieu de recharger, on peut v√©rifier le localStorage
  try {
    const overridesInStorage = localStorage.getItem('feature_flags_overrides');
    const overrides = overridesInStorage ? JSON.parse(overridesInStorage) : {};
    
    results.persistence.storagePresent = !!overridesInStorage;
    results.persistence.overridesInStorage = overrides;
    
    // V√©rifier que les overrides sont correctement stock√©s
    for (const flag of testFlags) {
      const expectedValue = results.override[flag]?.overrideValue;
      const storedValue = overrides[flag];
      
      results.persistence[flag] = {
        expectedValue,
        storedValue,
        success: storedValue === expectedValue
      };
    }
    
    console.log('üíæ Persistance des overrides:', 
      Object.values(results.persistence).filter(v => v.success).length === testFlags.length ? 
      '‚úÖ R√©ussie' : '‚ö†Ô∏è Partielle');
      
  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification de la persistance:', error);
    results.persistence.error = error.message;
  }
  
  // R√©initialiser les overrides
  window.featureFlagsService.resetOverrides();
  
  testResults.overrides = results.override;
  testResults.persistence = results.persistence;
  console.log('‚úÖ Tests d\'override termin√©s');
  
  return results;
}

/**
 * Ex√©cute les tests sp√©cifiques pour la fonctionnalit√© "Seven Majors Challenge"
 * @returns {Object} R√©sultats des tests
 */
export function runSevenMajorsChallengeTests() {
  console.log('üîç Ex√©cution des tests sp√©cifiques pour Seven Majors Challenge...');
  
  const results = {};
  
  // Tester chaque flag sp√©cifique
  for (const flag of TEST_CONFIG.testCases[4].flags) {
    try {
      const isEnabled = window.featureFlagsService.isEnabled(flag);
      console.log(`üö© ${flag}: ${isEnabled ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©'}`);
      results[flag] = { enabled: isEnabled, success: true };
      
      // Tester l'impact de la d√©sactivation pour les fonctionnalit√©s critiques
      if (flag === 'sevenMajorsChallenge' || flag === '3DColVisualization') {
        const originalState = isEnabled;
        
        // D√©sactiver temporairement
        window.featureFlagsService.override(flag, false);
        console.log(`üîÑ Test de d√©sactivation de ${flag}...`);
        
        // V√©rifier l'impact (id√©alement, il faudrait charger le composant et v√©rifier l'UI)
        // On simule ici cette v√©rification
        results[flag].disabledImpact = {
          message: `La fonctionnalit√© ${flag} a √©t√© temporairement d√©sactiv√©e pour test`,
          expectedBehavior: flag === 'sevenMajorsChallenge' ? 
            'Le composant SevenMajorsChallenge ne devrait pas √™tre rendu' : 
            'La visualisation 3D devrait √™tre remplac√©e par une alternative 2D'
        };
        
        // Restaurer l'√©tat original
        window.featureFlagsService.override(flag, originalState);
      }
    } catch (error) {
      console.error(`‚ùå Erreur lors du test du flag ${flag}:`, error);
      results[flag] = { error: error.message, success: false };
    }
  }
  
  testResults.specificFeatures = results;
  console.log('‚úÖ Tests sp√©cifiques pour Seven Majors Challenge termin√©s');
  
  return results;
}

/**
 * G√©n√®re un rapport des tests de feature flags
 * @returns {Object} Rapport de tests
 */
export function generateFeatureFlagsReport() {
  console.log('üìä G√©n√©ration du rapport de tests de feature flags...');
  
  const report = {
    summary: {
      basicFlags: {
        total: Object.keys(testResults.flagsBasic).length - 1, // -1 pour allFlags
        enabled: Object.values(testResults.flagsBasic)
          .filter(f => f.enabled && f.success).length,
        success: Object.values(testResults.flagsBasic)
          .filter(f => f.success).length
      },
      segmentation: {
        roles: Object.keys(testResults.segmentation.byRole).length,
        flagsPerRole: {}
      },
      variants: {
        total: Object.keys(testResults.variants).length,
        overrideSuccess: Object.values(testResults.variants)
          .filter(v => v.override && v.override.success).length
      },
      overrides: {
        total: Object.keys(testResults.overrides).length,
        success: Object.values(testResults.overrides)
          .filter(o => o.success).length
      },
      persistence: {
        success: testResults.persistence.storagePresent
      },
      specificFeatures: {
        total: Object.keys(testResults.specificFeatures).length,
        enabled: Object.values(testResults.specificFeatures)
          .filter(f => f.enabled && f.success).length
      }
    },
    details: testResults,
    timestamp: testResults.timestamp
  };
  
  // Compl√©ter les d√©tails de segmentation
  if (testResults.segmentation.byRole) {
    for (const [role, data] of Object.entries(testResults.segmentation.byRole)) {
      const flagsData = Object.entries(data)
        .filter(([key]) => key !== 'eligibleFlags')
        .map(([key, value]) => value);
      
      report.summary.segmentation.flagsPerRole[role] = {
        total: flagsData.length,
        enabled: flagsData.filter(f => f.enabled).length
      };
    }
  }
  
  console.log('‚úÖ Rapport de tests de feature flags g√©n√©r√©');
  console.table(report.summary.basicFlags);
  console.table(report.summary.segmentation.flagsPerRole);
  console.table(report.summary.variants);
  
  return report;
}

/**
 * Exporte les r√©sultats des tests au format JSON
 */
export function exportTestResults() {
  const jsonStr = JSON.stringify(testResults, null, 2);
  const blob = new Blob([jsonStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `feature-flags-test-results-${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  
  console.log('üíæ R√©sultats des tests export√©s');
}

/**
 * Ex√©cute tous les tests de feature flags
 */
export function runAllFeatureFlagsTests() {
  console.log('üöÄ D√©marrage de la suite de tests de feature flags...');
  
  runBasicFlagsTests();
  runSegmentationTests();
  runVariantTests();
  runOverrideTests();
  runSevenMajorsChallengeTests();
  
  const report = generateFeatureFlagsReport();
  
  console.log('üèÅ Suite de tests termin√©e');
  
  return report;
}

// Export de l'API de test
export default {
  runBasicFlagsTests,
  runSegmentationTests,
  runVariantTests,
  runOverrideTests,
  runSevenMajorsChallengeTests,
  generateFeatureFlagsReport,
  exportTestResults,
  runAllFeatureFlagsTests
};
