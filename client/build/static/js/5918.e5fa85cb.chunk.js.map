{"version":3,"file":"static/js/5918.e5fa85cb.chunk.js","mappings":"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","sources":["services/clientFingerprintService.js","services/enhancedAuthClient.js","components/auth/AuthErrorHandler.js","contexts/AuthContext.js"],"sourcesContent":["/**\n * Service de collecte d'empreintes client\n * Ce service génère une empreinte unique pour chaque appareil/navigateur \n * afin d'améliorer la sécurité du système d'authentification\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport * as UAParser from 'ua-parser-js';\n\nclass ClientFingerprintService {\n  constructor() {\n    this.fingerprintKey = 'client_fingerprint';\n    this.uaParser = new UAParser();\n    this.initFingerprint();\n  }\n\n  /**\n   * Initialise l'empreinte client si elle n'existe pas déjà\n   */\n  initFingerprint() {\n    if (!this.getFingerprint()) {\n      this.generateFingerprint();\n    }\n  }\n\n  /**\n   * Génère et stocke une nouvelle empreinte client\n   * @returns {Object} L'empreinte complète avec toutes ses composantes\n   */\n  generateFingerprint() {\n    const uuid = uuidv4();\n    const browserInfo = this.getBrowserInfo();\n    const osInfo = this.getOSInfo();\n    const screenInfo = this.getScreenInfo();\n    const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n    const languages = navigator.languages || [navigator.language || navigator.userLanguage];\n    \n    // Informations sur le matériel (si disponibles)\n    const hardwareInfo = this.getHardwareInfo();\n    \n    // Informations sur les capacités du navigateur\n    const capabilities = this.getCapabilities();\n    \n    const fingerprint = {\n      id: uuid,\n      browser: browserInfo,\n      os: osInfo,\n      screen: screenInfo,\n      timeZone,\n      languages,\n      hardware: hardwareInfo,\n      capabilities,\n      createdAt: new Date().toISOString()\n    };\n    \n    // Stocker l'empreinte complète\n    localStorage.setItem(this.fingerprintKey, JSON.stringify(fingerprint));\n    \n    return fingerprint;\n  }\n  \n  /**\n   * Récupère l'empreinte client stockée\n   * @returns {Object|null} L'empreinte client ou null si elle n'existe pas\n   */\n  getFingerprint() {\n    const stored = localStorage.getItem(this.fingerprintKey);\n    return stored ? JSON.parse(stored) : null;\n  }\n  \n  /**\n   * Récupère uniquement l'ID d'empreinte\n   * @returns {string|null} L'ID d'empreinte ou null\n   */\n  getFingerprintId() {\n    const fingerprint = this.getFingerprint();\n    return fingerprint ? fingerprint.id : null;\n  }\n  \n  /**\n   * Met à jour l'empreinte existante avec les données actuelles\n   * Utile pour détecter les changements de configuration\n   * @returns {Object} L'empreinte mise à jour\n   */\n  updateFingerprint() {\n    const currentFingerprint = this.getFingerprint();\n    if (!currentFingerprint) {\n      return this.generateFingerprint();\n    }\n    \n    // Garder l'ID existant mais mettre à jour les autres informations\n    const updatedFingerprint = {\n      ...this.generateFingerprint(),\n      id: currentFingerprint.id,\n      previousCreatedAt: currentFingerprint.createdAt,\n      updatedAt: new Date().toISOString()\n    };\n    \n    localStorage.setItem(this.fingerprintKey, JSON.stringify(updatedFingerprint));\n    return updatedFingerprint;\n  }\n  \n  /**\n   * Récupère les informations sur le navigateur\n   * @private\n   * @returns {Object} Informations sur le navigateur\n   */\n  getBrowserInfo() {\n    const browserResult = this.uaParser.getBrowser();\n    const engineResult = this.uaParser.getEngine();\n    \n    return {\n      name: browserResult.name || 'Unknown',\n      version: browserResult.version || 'Unknown',\n      engine: engineResult.name || 'Unknown',\n      engineVersion: engineResult.version || 'Unknown',\n      userAgent: navigator.userAgent\n    };\n  }\n  \n  /**\n   * Récupère les informations sur le système d'exploitation\n   * @private\n   * @returns {Object} Informations sur le système d'exploitation\n   */\n  getOSInfo() {\n    const osResult = this.uaParser.getOS();\n    \n    return {\n      name: osResult.name || 'Unknown',\n      version: osResult.version || 'Unknown',\n      platform: navigator.platform || 'Unknown'\n    };\n  }\n  \n  /**\n   * Récupère les informations sur l'écran\n   * @private\n   * @returns {Object} Informations sur l'écran\n   */\n  getScreenInfo() {\n    return {\n      width: window.screen.width,\n      height: window.screen.height,\n      colorDepth: window.screen.colorDepth,\n      pixelRatio: window.devicePixelRatio || 1,\n      orientation: window.screen.orientation ? window.screen.orientation.type : 'Unknown'\n    };\n  }\n  \n  /**\n   * Récupère les informations matérielles (si disponibles)\n   * @private\n   * @returns {Object} Informations sur le matériel\n   */\n  getHardwareInfo() {\n    const deviceResult = this.uaParser.getDevice();\n    const hardwareInfo = {\n      deviceType: deviceResult.type || 'Unknown',\n      deviceModel: deviceResult.model || 'Unknown',\n      deviceVendor: deviceResult.vendor || 'Unknown',\n      isMobile: this.isMobileDevice(),\n      isTablet: this.isTabletDevice()\n    };\n    \n    // Essayer d'obtenir des informations sur les cœurs CPU\n    if (navigator.hardwareConcurrency) {\n      hardwareInfo.cpuCores = navigator.hardwareConcurrency;\n    }\n    \n    // Essayer d'obtenir des informations sur la mémoire\n    if (navigator.deviceMemory) {\n      hardwareInfo.deviceMemory = navigator.deviceMemory;\n    }\n    \n    return hardwareInfo;\n  }\n  \n  /**\n   * Détermine si l'appareil est mobile\n   * @private\n   * @returns {boolean} True si l'appareil est un mobile\n   */\n  isMobileDevice() {\n    const deviceType = this.uaParser.getDevice().type;\n    return deviceType === 'mobile' || /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(navigator.userAgent);\n  }\n  \n  /**\n   * Détermine si l'appareil est une tablette\n   * @private\n   * @returns {boolean} True si l'appareil est une tablette\n   */\n  isTabletDevice() {\n    const deviceType = this.uaParser.getDevice().type;\n    return deviceType === 'tablet' || /(tablet|ipad|playbook|silk)|(android(?!.*mobile))/i.test(navigator.userAgent);\n  }\n  \n  /**\n   * Récupère les capacités techniques du navigateur\n   * @private\n   * @returns {Object} Capacités du navigateur\n   */\n  getCapabilities() {\n    const capabilities = {\n      cookies: navigator.cookieEnabled,\n      localStorage: this.isLocalStorageEnabled(),\n      sessionStorage: this.isSessionStorageEnabled(),\n      webGL: this.isWebGLEnabled(),\n      webRTC: this.isWebRTCEnabled(),\n      canvas: this.isCanvasEnabled(),\n      svg: this.isSVGEnabled(),\n      webP: null, // Sera déterminé de manière asynchrone\n      audio: this.isAudioEnabled(),\n      video: this.isVideoEnabled(),\n      touchPoints: 'maxTouchPoints' in navigator ? navigator.maxTouchPoints : 0,\n      bluetooth: 'bluetooth' in navigator,\n      gyroscope: this.hasGyroscope(),\n      serviceWorkers: 'serviceWorker' in navigator\n    };\n    \n    // Tester le support WebP de manière asynchrone\n    this.testWebPSupport().then(webPSupported => {\n      capabilities.webP = webPSupported;\n      \n      // Mettre à jour les capacités stockées\n      const fingerprint = this.getFingerprint();\n      if (fingerprint) {\n        fingerprint.capabilities = {\n          ...fingerprint.capabilities,\n          webP: webPSupported\n        };\n        localStorage.setItem(this.fingerprintKey, JSON.stringify(fingerprint));\n      }\n    });\n    \n    return capabilities;\n  }\n  \n  /**\n   * Vérifie si le localStorage est disponible\n   * @private\n   * @returns {boolean} True si le localStorage est disponible\n   */\n  isLocalStorageEnabled() {\n    try {\n      localStorage.setItem('test', 'test');\n      localStorage.removeItem('test');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Vérifie si le sessionStorage est disponible\n   * @private\n   * @returns {boolean} True si le sessionStorage est disponible\n   */\n  isSessionStorageEnabled() {\n    try {\n      sessionStorage.setItem('test', 'test');\n      sessionStorage.removeItem('test');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Vérifie si WebGL est disponible\n   * @private\n   * @returns {boolean} True si WebGL est disponible\n   */\n  isWebGLEnabled() {\n    try {\n      const canvas = document.createElement('canvas');\n      return !!(window.WebGLRenderingContext && \n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Vérifie si WebRTC est disponible\n   * @private\n   * @returns {boolean} True si WebRTC est disponible\n   */\n  isWebRTCEnabled() {\n    return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || \n           !!(navigator.getUserMedia) || \n           !!(navigator.webkitGetUserMedia) || \n           !!(navigator.mozGetUserMedia);\n  }\n  \n  /**\n   * Vérifie si Canvas est disponible\n   * @private\n   * @returns {boolean} True si Canvas est disponible\n   */\n  isCanvasEnabled() {\n    try {\n      const canvas = document.createElement('canvas');\n      return !!(canvas.getContext && canvas.getContext('2d'));\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Vérifie si SVG est disponible\n   * @private\n   * @returns {boolean} True si SVG est disponible\n   */\n  isSVGEnabled() {\n    return !!document.createElementNS && \n           !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;\n  }\n  \n  /**\n   * Teste le support du format WebP\n   * @private\n   * @returns {Promise<boolean>} Promise résolu avec true si WebP est supporté\n   */\n  testWebPSupport() {\n    return new Promise(resolve => {\n      const webP = new Image();\n      webP.onload = webP.onerror = function() {\n        resolve(webP.height === 2);\n      };\n      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';\n    });\n  }\n  \n  /**\n   * Vérifie si l'API Audio est disponible\n   * @private\n   * @returns {boolean} True si l'API Audio est disponible\n   */\n  isAudioEnabled() {\n    return !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);\n  }\n  \n  /**\n   * Vérifie si l'API Vidéo est disponible\n   * @private\n   * @returns {boolean} True si l'API Vidéo est disponible\n   */\n  isVideoEnabled() {\n    try {\n      const video = document.createElement('video');\n      return !!(video.canPlayType);\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Vérifie si le gyroscope est disponible\n   * @private\n   * @returns {boolean} True si le gyroscope est disponible\n   */\n  hasGyroscope() {\n    return 'DeviceOrientationEvent' in window || 'DeviceMotionEvent' in window;\n  }\n  \n  /**\n   * Récupère une version simplifiée de l'empreinte pour l'authentification\n   * @returns {Object} Empreinte simplifiée\n   */\n  getAuthFingerprint() {\n    const fingerprint = this.getFingerprint() || this.generateFingerprint();\n    \n    return {\n      id: fingerprint.id,\n      browser: `${fingerprint.browser.name}/${fingerprint.browser.version}`,\n      os: `${fingerprint.os.name}/${fingerprint.os.version}`,\n      screen: `${fingerprint.screen.width}x${fingerprint.screen.height}`,\n      isMobile: fingerprint.hardware.isMobile,\n      timeZone: fingerprint.timeZone,\n      language: fingerprint.languages[0] || 'unknown'\n    };\n  }\n}\n\nconst clientFingerprintService = new ClientFingerprintService();\nexport default clientFingerprintService;\n","/**\n * Client d'authentification amélioré\n * Gère la rotation des tokens JWT, les périodes de grâce et la révocation sélective des tokens\n */\n\nimport { jwtDecode } from 'jwt-decode';\nimport clientFingerprintService from './clientFingerprintService';\n\nexport class AuthError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AuthError';\n    this.code = code;\n  }\n}\n\nexport class LocalStorageTokenStore {\n  constructor(prefix = 'auth_') {\n    this.prefix = prefix;\n  }\n\n  async getAccessToken() {\n    return localStorage.getItem(`${this.prefix}access_token`);\n  }\n\n  async getRefreshToken() {\n    return localStorage.getItem(`${this.prefix}refresh_token`);\n  }\n\n  async setTokens(accessToken, refreshToken) {\n    localStorage.setItem(`${this.prefix}access_token`, accessToken);\n    localStorage.setItem(`${this.prefix}refresh_token`, refreshToken);\n  }\n\n  async clearTokens() {\n    localStorage.removeItem(`${this.prefix}access_token`);\n    localStorage.removeItem(`${this.prefix}refresh_token`);\n  }\n}\n\nexport class EnhancedAuthClient {\n  constructor(options = {}) {\n    this.baseUrl = options.baseUrl || '/api/auth';\n    this.tokenStorage = options.tokenStorage || new LocalStorageTokenStore();\n    this.refreshThreshold = options.refreshThreshold || 300; // 5 minutes in seconds\n    this.graceEnabled = options.graceEnabled !== false; // Enable grace period by default\n    this.onSessionExpired = options.onSessionExpired || (() => {\n      window.dispatchEvent(new CustomEvent('auth:session-expired'));\n    });\n    this.onTokenRevoked = options.onTokenRevoked || (() => {\n      window.dispatchEvent(new CustomEvent('auth:token-revoked'));\n    });\n    \n    // Setup token refresh interval\n    this.refreshInterval = setInterval(() => {\n      this.checkAndRefreshToken();\n    }, (options.refreshCheckInterval || 60) * 1000); // Check every minute by default\n  }\n\n  /**\n   * Connecte l'utilisateur\n   * @param {Object} credentials Identifiants de connexion (email, password)\n   * @returns {Promise<Object>} Informations utilisateur\n   */\n  async login(credentials) {\n    try {\n      // Ajouter l'empreinte client aux données de connexion\n      const clientFingerprint = clientFingerprintService.getAuthFingerprint();\n      const loginData = {\n        ...credentials,\n        clientFingerprint\n      };\n\n      const response = await fetch(`${this.baseUrl}/login`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(loginData)\n      });\n      \n      if (!response.ok) {\n        const error = await response.json();\n        throw new AuthError(error.message, error.code);\n      }\n      \n      const data = await response.json();\n      await this.tokenStorage.setTokens(data.accessToken, data.refreshToken);\n      return data.user;\n    } catch (error) {\n      console.error('Login failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Déconnecte l'utilisateur\n   * @param {boolean} revokeAll Si true, révoque tous les tokens de l'utilisateur sur tous les appareils\n   * @returns {Promise<void>}\n   */\n  async logout(revokeAll = false) {\n    try {\n      const refreshToken = await this.tokenStorage.getRefreshToken();\n      if (refreshToken) {\n        // Révoquer le token sur le serveur\n        await fetch(`${this.baseUrl}/logout`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${await this.tokenStorage.getAccessToken()}`\n          },\n          body: JSON.stringify({ \n            refreshToken,\n            revokeAll,\n            clientFingerprint: clientFingerprintService.getFingerprintId()\n          })\n        });\n      }\n    } catch (error) {\n      console.warn('Error during logout:', error);\n    } finally {\n      // Supprimer les tokens localement indépendamment de la réponse du serveur\n      await this.tokenStorage.clearTokens();\n      clearInterval(this.refreshInterval);\n    }\n  }\n\n  /**\n   * Fournit une fonction fetch authentifiée\n   * @returns {Promise<Function>} Une fonction fetch avec authentification\n   */\n  async getAuthenticatedFetch() {\n    const accessToken = await this.tokenStorage.getAccessToken();\n    if (!accessToken) {\n      throw new AuthError('No access token available', 'no_token');\n    }\n    \n    return async (url, options = {}) => {\n      // Cloner les options pour éviter de modifier l'original\n      const fetchOptions = { ...options };\n      \n      // Ajouter l'en-tête d'autorisation\n      fetchOptions.headers = {\n        ...fetchOptions.headers,\n        'Authorization': `Bearer ${accessToken}`\n      };\n      \n      // Ajouter l'empreinte client aux en-têtes\n      const fingerprint = clientFingerprintService.getFingerprintId();\n      if (fingerprint) {\n        fetchOptions.headers['X-Client-ID'] = fingerprint;\n      }\n      \n      try {\n        const response = await fetch(url, fetchOptions);\n        \n        // Gérer les erreurs d'authentification\n        if (response.status === 401 || response.status === 403) {\n          let errorData;\n          try {\n            errorData = await response.json();\n          } catch (e) {\n            errorData = { message: 'Authentication error', code: 'auth_error' };\n          }\n          \n          // Si le token est expiré mais dans la période de grâce, essayer de le rafraîchir\n          if (errorData.code === 'token_expired' && this.graceEnabled) {\n            try {\n              const newToken = await this.refreshToken();\n              if (newToken) {\n                // Réessayer avec le nouveau token\n                fetchOptions.headers['Authorization'] = `Bearer ${newToken}`;\n                return fetch(url, fetchOptions);\n              }\n            } catch (refreshError) {\n              console.error('Failed to refresh token during grace period:', refreshError);\n            }\n          }\n          \n          throw new AuthError(errorData.message, errorData.code);\n        }\n        \n        return response;\n      } catch (error) {\n        if (error instanceof AuthError) {\n          // Gérer les erreurs d'authentification spécifiques\n          if (error.code === 'token_revoked') {\n            await this.tokenStorage.clearTokens();\n            this.onTokenRevoked();\n          } else if (error.code === 'session_expired' || error.code === 'invalid_token') {\n            await this.tokenStorage.clearTokens();\n            this.onSessionExpired();\n          }\n        }\n        throw error;\n      }\n    };\n  }\n\n  /**\n   * Rafraîchit le token d'accès\n   * @returns {Promise<string>} Nouveau token d'accès\n   */\n  async refreshToken() {\n    try {\n      const refreshToken = await this.tokenStorage.getRefreshToken();\n      if (!refreshToken) {\n        throw new AuthError('No refresh token available', 'no_refresh_token');\n      }\n      \n      // Inclure l'empreinte client dans la demande de rafraîchissement\n      const fingerprint = clientFingerprintService.getAuthFingerprint();\n      \n      const response = await fetch(`${this.baseUrl}/refresh`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          refreshToken,\n          clientFingerprint: fingerprint\n        })\n      });\n      \n      if (!response.ok) {\n        const error = await response.json();\n        throw new AuthError(error.message, error.code);\n      }\n      \n      const data = await response.json();\n      await this.tokenStorage.setTokens(data.accessToken, data.refreshToken);\n      return data.accessToken;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      if (error.code === 'invalid_refresh_token' || error.code === 'refresh_token_expired') {\n        await this.tokenStorage.clearTokens();\n        this.onSessionExpired();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Vérifie si le token est sur le point d'expirer et le rafraîchit si nécessaire\n   * @returns {Promise<void>}\n   */\n  async checkAndRefreshToken() {\n    try {\n      const accessToken = await this.tokenStorage.getAccessToken();\n      if (!accessToken) return;\n      \n      // Décoder le token sans vérification pour vérifier l'expiration\n      const payload = this._decodeToken(accessToken);\n      if (!payload || !payload.exp) return;\n      \n      const now = Math.floor(Date.now() / 1000);\n      const timeUntilExpiry = payload.exp - now;\n      \n      // Rafraîchir si le token est sur le point d'expirer\n      if (timeUntilExpiry < this.refreshThreshold) {\n        await this.refreshToken();\n      }\n    } catch (error) {\n      console.warn('Error checking token expiration:', error);\n    }\n  }\n\n  /**\n   * Décode un token JWT sans vérification de signature\n   * @private\n   * @param {string} token Token JWT\n   * @returns {Object|null} Contenu décodé du token\n   */\n  _decodeToken(token) {\n    try {\n      return jwtDecode(token);\n    } catch (error) {\n      console.error('Error decoding token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Vérifie si l'utilisateur est authentifié\n   * @returns {Promise<boolean>} Statut d'authentification\n   */\n  async isAuthenticated() {\n    const accessToken = await this.tokenStorage.getAccessToken();\n    if (!accessToken) return false;\n    \n    const payload = this._decodeToken(accessToken);\n    if (!payload || !payload.exp) return false;\n    \n    const now = Math.floor(Date.now() / 1000);\n    return payload.exp > now;\n  }\n\n  /**\n   * Récupère les informations utilisateur du token\n   * @returns {Promise<Object|null>} Informations utilisateur\n   */\n  async getUserInfo() {\n    const accessToken = await this.tokenStorage.getAccessToken();\n    if (!accessToken) return null;\n    \n    const payload = this._decodeToken(accessToken);\n    return payload ? payload.user : null;\n  }\n\n  /**\n   * Nettoie les ressources utilisées par le client\n   */\n  dispose() {\n    clearInterval(this.refreshInterval);\n  }\n}\n\n// Export d'une instance singleton avec les paramètres par défaut\nconst enhancedAuthClient = new EnhancedAuthClient();\nexport default enhancedAuthClient;\n","/**\n * Gestionnaire d'erreurs d'authentification\n * Affiche différentes interfaces utilisateur selon le type d'erreur d'authentification\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport {\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogContentText,\n  DialogActions,\n  Button,\n  Snackbar,\n  Alert,\n  Typography,\n  Box\n} from '@mui/material';\nimport {\n  ErrorOutline as ErrorIcon,\n  LockOutlined as LockIcon,\n  RefreshOutlined as RefreshIcon,\n  DevicesOutlined as DevicesIcon,\n  WarningAmberOutlined as WarningIcon\n} from '@mui/icons-material';\n\n// Mapping des codes d'erreur vers des configurations d'affichage\nconst errorConfig = {\n  // Erreurs de session\n  'token_expired': {\n    title: 'Session expirée',\n    message: 'Votre session a expiré. Veuillez vous reconnecter.',\n    icon: <RefreshIcon color=\"warning\" />,\n    severity: 'warning',\n    buttons: [\n      { label: 'Se reconnecter', action: 'login', color: 'primary' }\n    ]\n  },\n  'session_expired': {\n    title: 'Session expirée',\n    message: 'Votre session a expiré. Veuillez vous reconnecter.',\n    icon: <RefreshIcon color=\"warning\" />,\n    severity: 'warning',\n    buttons: [\n      { label: 'Se reconnecter', action: 'login', color: 'primary' }\n    ]\n  },\n  'token_revoked': {\n    title: 'Session révoquée',\n    message: 'Votre session a été révoquée. Veuillez vous reconnecter.',\n    icon: <LockIcon color=\"error\" />,\n    severity: 'error',\n    buttons: [\n      { label: 'Se reconnecter', action: 'login', color: 'primary' }\n    ]\n  },\n  \n  // Erreurs d'appareil\n  'device_changed': {\n    title: 'Nouvel appareil détecté',\n    message: 'Nous avons détecté une connexion depuis un nouvel appareil. Pour votre sécurité, veuillez vous reconnecter.',\n    icon: <DevicesIcon color=\"warning\" />,\n    severity: 'warning',\n    buttons: [\n      { label: 'Se reconnecter', action: 'login', color: 'primary' }\n    ]\n  },\n  'too_many_devices': {\n    title: 'Trop d\\'appareils',\n    message: 'Vous êtes connecté sur trop d\\'appareils différents. Veuillez vous déconnecter de l\\'un d\\'entre eux et réessayer.',\n    icon: <DevicesIcon color=\"error\" />,\n    severity: 'error',\n    buttons: [\n      { label: 'Gérer mes appareils', action: 'manage_devices', color: 'primary' },\n      { label: 'Se reconnecter', action: 'login', color: 'secondary' }\n    ]\n  },\n  \n  // Erreurs de sécurité\n  'account_locked': {\n    title: 'Compte verrouillé',\n    message: 'Votre compte a été temporairement verrouillé pour des raisons de sécurité. Veuillez réessayer dans quelques minutes ou contacter le support.',\n    icon: <LockIcon color=\"error\" />,\n    severity: 'error',\n    buttons: [\n      { label: 'Contacter le support', action: 'support', color: 'primary' },\n      { label: 'Réessayer', action: 'login', color: 'secondary' }\n    ]\n  },\n  \n  // Erreur par défaut\n  'default': {\n    title: 'Erreur d\\'authentification',\n    message: 'Une erreur d\\'authentification s\\'est produite. Veuillez vous reconnecter.',\n    icon: <ErrorIcon color=\"error\" />,\n    severity: 'error',\n    buttons: [\n      { label: 'Se reconnecter', action: 'login', color: 'primary' }\n    ]\n  }\n};\n\n/**\n * Composant pour gérer les erreurs d'authentification\n * @param {Object} props Propriétés du composant\n * @param {string} props.errorCode Code d'erreur d'authentification\n * @param {string} props.errorMessage Message d'erreur personnalisé (optionnel)\n * @param {boolean} props.open Si le dialogue est ouvert\n * @param {Function} props.onClose Fonction à appeler lors de la fermeture\n * @param {Function} props.onAction Fonction à appeler lors d'une action (login, manage_devices, support)\n * @param {boolean} props.useSnackbar Utiliser une snackbar au lieu d'un dialogue pour les erreurs moins critiques\n */\nconst AuthErrorHandler = ({\n  errorCode = 'default',\n  errorMessage,\n  open = false,\n  onClose,\n  onAction,\n  useSnackbar = false\n}) => {\n  const navigate = useNavigate();\n  const [showError, setShowError] = useState(open);\n  \n  // Récupérer la configuration pour ce code d'erreur\n  const config = errorConfig[errorCode] || errorConfig.default;\n  \n  useEffect(() => {\n    setShowError(open);\n  }, [open, errorCode]);\n  \n  // Gestionnaire de fermeture\n  const handleClose = () => {\n    setShowError(false);\n    if (onClose) onClose();\n  };\n  \n  // Gestionnaire d'action\n  const handleAction = (action) => {\n    handleClose();\n    \n    if (onAction) {\n      onAction(action);\n      return;\n    }\n    \n    // Actions par défaut si aucun gestionnaire personnalisé n'est fourni\n    switch (action) {\n      case 'login':\n        navigate('/login');\n        break;\n      case 'manage_devices':\n        navigate('/account/devices');\n        break;\n      case 'support':\n        navigate('/support');\n        break;\n      default:\n        console.warn(`Action non gérée: ${action}`);\n    }\n  };\n  \n  // Utiliser une snackbar pour les erreurs moins critiques si demandé\n  if (useSnackbar && (config.severity === 'info' || config.severity === 'warning')) {\n    return (\n      <Snackbar\n        open={showError}\n        autoHideDuration={6000}\n        onClose={handleClose}\n        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}\n      >\n        <Alert\n          onClose={handleClose}\n          severity={config.severity}\n          variant=\"filled\"\n          sx={{ width: '100%' }}\n          action={\n            <Button \n              color=\"inherit\" \n              size=\"small\" \n              onClick={() => handleAction(config.buttons[0].action)}\n            >\n              {config.buttons[0].label}\n            </Button>\n          }\n        >\n          {errorMessage || config.message}\n        </Alert>\n      </Snackbar>\n    );\n  }\n  \n  // Utiliser un dialogue pour les erreurs critiques\n  return (\n    <Dialog\n      open={showError}\n      onClose={handleClose}\n      aria-labelledby=\"auth-error-title\"\n      aria-describedby=\"auth-error-description\"\n      PaperProps={{\n        sx: {\n          width: '100%',\n          maxWidth: 500,\n          borderTop: `4px solid ${\n            config.severity === 'error' ? 'error.main' :\n            config.severity === 'warning' ? 'warning.main' : 'primary.main'\n          }`\n        }\n      }}\n    >\n      <DialogTitle id=\"auth-error-title\" sx={{ pb: 1 }}>\n        <Box display=\"flex\" alignItems=\"center\" gap={1}>\n          {config.icon}\n          <Typography variant=\"h6\" component=\"span\">\n            {config.title}\n          </Typography>\n        </Box>\n      </DialogTitle>\n      <DialogContent>\n        <DialogContentText id=\"auth-error-description\">\n          {errorMessage || config.message}\n        </DialogContentText>\n      </DialogContent>\n      <DialogActions sx={{ px: 3, pb: 2 }}>\n        {config.buttons.map((button, index) => (\n          <Button\n            key={index}\n            onClick={() => handleAction(button.action)}\n            color={button.color}\n            variant={index === 0 ? 'contained' : 'outlined'}\n          >\n            {button.label}\n          </Button>\n        ))}\n      </DialogActions>\n    </Dialog>\n  );\n};\n\nexport default AuthErrorHandler;\n","/**\n * Contexte d'authentification pour l'application\n * Fournit des fonctionnalités d'authentification à l'ensemble de l'application\n */\n\nimport React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport enhancedAuthClient from '../services/enhancedAuthClient';\nimport AuthErrorHandler from '../components/auth/AuthErrorHandler';\n\n// Création du contexte\nconst AuthContext = createContext(null);\n\n/**\n * Fournisseur du contexte d'authentification\n * @param {Object} props Props du composant\n * @param {React.ReactNode} props.children Enfants du composant\n */\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const navigate = useNavigate();\n\n  // Fonction pour charger le profil utilisateur\n  const loadUserProfile = useCallback(async () => {\n    try {\n      const userInfo = await enhancedAuthClient.getUserInfo();\n      setCurrentUser(userInfo);\n      return userInfo;\n    } catch (err) {\n      console.error('Erreur lors du chargement du profil utilisateur:', err);\n      setCurrentUser(null);\n      return null;\n    }\n  }, []);\n\n  // Vérifier l'état d'authentification au chargement\n  useEffect(() => {\n    const checkAuth = async () => {\n      setLoading(true);\n      try {\n        const isAuthenticated = await enhancedAuthClient.isAuthenticated();\n        \n        if (isAuthenticated) {\n          await loadUserProfile();\n        } else {\n          setCurrentUser(null);\n        }\n      } catch (err) {\n        console.error('Erreur lors de la vérification de l\\'authentification:', err);\n        setCurrentUser(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    checkAuth();\n  }, [loadUserProfile]);\n\n  // Gérer les événements d'authentification\n  useEffect(() => {\n    const handleSessionExpired = () => {\n      setCurrentUser(null);\n      setError({\n        code: 'session_expired',\n        message: 'Votre session a expiré. Veuillez vous reconnecter.'\n      });\n    };\n\n    const handleTokenRevoked = () => {\n      setCurrentUser(null);\n      setError({\n        code: 'token_revoked',\n        message: 'Votre session a été révoquée. Veuillez vous reconnecter.'\n      });\n    };\n\n    const handleAuthError = (event) => {\n      setError(event.detail);\n    };\n\n    // S'abonner aux événements\n    window.addEventListener('auth:session-expired', handleSessionExpired);\n    window.addEventListener('auth:token-revoked', handleTokenRevoked);\n    window.addEventListener('auth:error', handleAuthError);\n\n    // Se désabonner à la destruction\n    return () => {\n      window.removeEventListener('auth:session-expired', handleSessionExpired);\n      window.removeEventListener('auth:token-revoked', handleTokenRevoked);\n      window.removeEventListener('auth:error', handleAuthError);\n    };\n  }, [navigate]);\n\n  // Fonction de connexion\n  const login = async (credentials) => {\n    setLoading(true);\n    try {\n      const user = await enhancedAuthClient.login(credentials);\n      setCurrentUser(user);\n      return user;\n    } catch (err) {\n      console.error('Erreur de connexion:', err);\n      setError({\n        code: err.code || 'auth_error',\n        message: err.message || 'Erreur lors de la connexion'\n      });\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Fonction de déconnexion\n  const logout = async (revokeAll = false) => {\n    setLoading(true);\n    try {\n      await enhancedAuthClient.logout(revokeAll);\n      setCurrentUser(null);\n      navigate('/login');\n    } catch (err) {\n      console.error('Erreur lors de la déconnexion:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Fonction pour obtenir un fetch authentifié\n  const getAuthFetch = useCallback(async () => {\n    try {\n      return await enhancedAuthClient.getAuthenticatedFetch();\n    } catch (err) {\n      console.error('Erreur lors de la récupération du fetch authentifié:', err);\n      if (err.code === 'no_token') {\n        setCurrentUser(null);\n      }\n      throw err;\n    }\n  }, []);\n\n  // Fermeture du dialogue d'erreur\n  const handleErrorClose = () => {\n    setError(null);\n  };\n\n  // Gestionnaire d'action d'erreur\n  const handleErrorAction = (action) => {\n    setError(null);\n    \n    switch (action) {\n      case 'login':\n        navigate('/login');\n        break;\n      case 'manage_devices':\n        navigate('/account/devices');\n        break;\n      default:\n        // Autres actions\n        break;\n    }\n  };\n\n  // Valeurs exposées par le contexte\n  const contextValue = {\n    currentUser,\n    loading,\n    isAuthenticated: !!currentUser,\n    login,\n    logout,\n    getAuthFetch,\n    loadUserProfile,\n    error\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n      \n      {/* Gestionnaire d'erreurs d'authentification */}\n      {error && (\n        <AuthErrorHandler\n          errorCode={error.code}\n          errorMessage={error.message}\n          open={!!error}\n          onClose={handleErrorClose}\n          onAction={handleErrorAction}\n          useSnackbar={error.code === 'token_expired'} // Utiliser snackbar pour les erreurs moins critiques\n        />\n      )}\n    </AuthContext.Provider>\n  );\n};\n\n/**\n * Hook pour utiliser le contexte d'authentification\n * @returns {Object} Contexte d'authentification\n */\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth doit être utilisé à l\\'intérieur d\\'un AuthProvider');\n  }\n  return context;\n};\n\nexport default AuthContext;\n"],"names":["constructor","this","fingerprintKey","uaParser","UAParser","initFingerprint","getFingerprint","generateFingerprint","fingerprint","id","uuidv4","browser","getBrowserInfo","os","getOSInfo","screen","getScreenInfo","timeZone","Intl","DateTimeFormat","resolvedOptions","languages","navigator","language","userLanguage","hardware","getHardwareInfo","capabilities","getCapabilities","createdAt","Date","toISOString","localStorage","setItem","JSON","stringify","stored","getItem","parse","getFingerprintId","updateFingerprint","currentFingerprint","updatedFingerprint","previousCreatedAt","updatedAt","browserResult","getBrowser","engineResult","getEngine","name","version","engine","engineVersion","userAgent","osResult","getOS","platform","width","window","height","colorDepth","pixelRatio","devicePixelRatio","orientation","type","deviceResult","getDevice","hardwareInfo","deviceType","deviceModel","model","deviceVendor","vendor","isMobile","isMobileDevice","isTablet","isTabletDevice","hardwareConcurrency","cpuCores","deviceMemory","test","cookies","cookieEnabled","isLocalStorageEnabled","sessionStorage","isSessionStorageEnabled","webGL","isWebGLEnabled","webRTC","isWebRTCEnabled","canvas","isCanvasEnabled","svg","isSVGEnabled","webP","audio","isAudioEnabled","video","isVideoEnabled","touchPoints","maxTouchPoints","bluetooth","gyroscope","hasGyroscope","serviceWorkers","testWebPSupport","then","webPSupported","removeItem","e","document","createElement","WebGLRenderingContext","getContext","mediaDevices","getUserMedia","webkitGetUserMedia","mozGetUserMedia","createElementNS","createSVGRect","Promise","resolve","Image","onload","onerror","src","AudioContext","webkitAudioContext","mozAudioContext","canPlayType","getAuthFingerprint","AuthError","Error","message","code","super","LocalStorageTokenStore","prefix","arguments","length","undefined","getAccessToken","getRefreshToken","setTokens","accessToken","refreshToken","clearTokens","options","baseUrl","tokenStorage","refreshThreshold","graceEnabled","onSessionExpired","dispatchEvent","CustomEvent","onTokenRevoked","refreshInterval","setInterval","checkAndRefreshToken","refreshCheckInterval","login","credentials","clientFingerprint","clientFingerprintService","loginData","response","fetch","method","headers","body","ok","error","json","data","user","console","logout","revokeAll","warn","clearInterval","getAuthenticatedFetch","_this","async","url","fetchOptions","status","errorData","newToken","refreshError","payload","_decodeToken","exp","now","Math","floor","token","jwtDecode","isAuthenticated","getUserInfo","dispose","RefreshIcon","LockIcon","DevicesIcon","ErrorIcon","AuthContext","createContext","useAuth","context","useContext"],"sourceRoot":""}