{"version":3,"file":"static/js/9193.006a9dfa.chunk.js","mappings":"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","sources":["services/featureFlags.js","components/common/NotificationSystem.js","contexts/CommunityContext.js"],"sourcesContent":["/**\n * Service de gestion des Feature Flags\n * Permet l'activation/désactivation de fonctionnalités sans redéploiement\n * Supporte plusieurs sources de configuration (local, API, localStorage)\n */\nimport axios from 'axios';\nimport { useEffect, useState, createContext, useContext } from 'react';\n\n// Valeurs par défaut des feature flags (utilisées en fallback)\nconst DEFAULT_FLAGS = {\n  // Fonctionnalités liées à l'interface utilisateur\n  enableDarkMode: false,\n  showBetaFeatures: false,\n  useNewNavigation: false,\n  \n  // Fonctionnalités liées aux défis\n  enableSevenMajorsChallenge: true,\n  enableMonthlyChallenge: true,\n  enableSocialSharing: true,\n  \n  // Fonctionnalités liées à l'API et aux performances\n  enableApiCaching: true,\n  enablePerformanceMonitoring: true,\n  \n  // Fonctionnalités expérimentales\n  enable3DColVisualization: true,\n  enableProgressiveLoading3D: true,  // Nouveau flag pour le chargement progressif des visualisations 3D\n  enableAIRecommendations: false,\n  enableRealTimeWeather: true,\n  \n  // Fonctionnalités liées au cache et à l'optimisation\n  enableAdvancedCaching: true,      // Nouveau flag pour le système de cache avancé\n  enableOfflineMode: false,         // Nouveau flag pour le mode hors ligne\n  enableLazyLoadingImages: true,    // Nouveau flag pour le chargement paresseux des images\n  \n  // Fonctionnalités administratives\n  enableAdvancedMetrics: true,\n  enableBulkOperations: false,\n  \n  // Fonctionnalités liées à la nutrition\n  enableNutritionPlanner: true,     // Nouveau flag pour le planificateur de nutrition\n  enableMealSuggestions: true,      // Nouveau flag pour les suggestions de repas\n  enableColSpecificNutrition: true, // Nouveau flag pour la nutrition spécifique aux cols\n  \n  // Fonctionnalités liées à l'entraînement\n  enableTrainingPrograms: true,     // Nouveau flag pour les programmes d'entraînement\n  enablePerformanceAnalytics: true, // Nouveau flag pour les analyses de performance\n  enableColSpecificTraining: true,  // Nouveau flag pour l'entraînement spécifique aux cols\n  \n  // Fonctionnalités liées à la montagne\n  enableMountainModule: true,       // Nouveau flag pour le module montagne\n  enableRegionalTrainingPlans: true // Nouveau flag pour les plans d'entraînement par région\n};\n\n// Types d'environnement supportés\nconst ENVIRONMENTS = {\n  DEVELOPMENT: 'development',\n  STAGING: 'staging',\n  PRODUCTION: 'production'\n};\n\n// Contexte React pour fournir les flags à travers l'application\nconst FeatureFlagsContext = createContext({\n  flags: DEFAULT_FLAGS,\n  isLoading: true,\n  error: null,\n  updateFlag: () => {},\n  refreshFlags: () => {},\n  isEnabled: () => false,     // Nouvelle méthode pour vérifier plus facilement un flag\n  getVariant: () => null      // Nouvelle méthode pour les tests A/B\n});\n\n/**\n * Classe principale de gestion des feature flags\n */\nclass FeatureFlagsService {\n  constructor() {\n    this.flags = { ...DEFAULT_FLAGS };\n    this.subscribers = [];\n    this.isInitialized = false;\n    this.lastFetchTime = 0;\n    this.cacheDuration = 5 * 60 * 1000; // 5 minutes en ms\n    this.environment = process.env.NODE_ENV || ENVIRONMENTS.DEVELOPMENT;\n    this.userSegment = null;\n    this.flagsHistory = {}; // Historique des changements de flags\n  }\n\n  /**\n   * Initialise le service et charge les flags depuis toutes les sources\n   * @returns {Promise<Object>} Les feature flags\n   */\n  async initialize() {\n    if (this.isInitialized) {\n      return this.flags;\n    }\n\n    try {\n      // Déterminer le segment utilisateur pour les flags ciblés\n      this.determineUserSegment();\n      \n      // Chargement en cascade avec priorité (localStorage > API > defaults)\n      await this.loadFlagsFromLocalStorage();\n      await this.fetchFlagsFromApi();\n      \n      // Vérifier les flags qui doivent être activés/désactivés par environnement\n      this.applyEnvironmentOverrides();\n      \n      // Initialiser l'historique des flags\n      Object.keys(this.flags).forEach(key => {\n        this.flagsHistory[key] = [{\n          value: this.flags[key],\n          timestamp: Date.now(),\n          source: 'initialization'\n        }];\n      });\n      \n      this.isInitialized = true;\n      this.notifySubscribers();\n      \n      return this.flags;\n    } catch (error) {\n      console.error('Erreur lors de l\\'initialisation des feature flags:', error);\n      // En cas d'erreur, utiliser les flags par défaut\n      return this.flags;\n    }\n  }\n\n  /**\n   * Détermine le segment utilisateur pour une expérience personnalisée\n   */\n  determineUserSegment() {\n    try {\n      // Récupérer les informations utilisateur du localStorage\n      const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');\n      \n      // On peut déterminer un segment basé sur différents critères\n      if (userInfo.role === 'admin') {\n        this.userSegment = 'admin';\n      } else if (userInfo.visits && userInfo.visits > 10) {\n        this.userSegment = 'power_user';\n      } else if (userInfo.registeredAt) {\n        const registrationDate = new Date(userInfo.registeredAt);\n        const oneMonthAgo = new Date();\n        oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n        \n        if (registrationDate > oneMonthAgo) {\n          this.userSegment = 'new_user';\n        } else {\n          this.userSegment = 'regular_user';\n        }\n      } else {\n        this.userSegment = 'anonymous';\n      }\n    } catch (error) {\n      console.error('Erreur lors de la détermination du segment utilisateur:', error);\n      this.userSegment = 'unknown';\n    }\n  }\n\n  /**\n   * Applique les valeurs par défaut spécifiques à l'environnement\n   */\n  applyEnvironmentOverrides() {\n    // Désactiver certaines fonctionnalités en production pour éviter les problèmes\n    if (this.environment === ENVIRONMENTS.PRODUCTION) {\n      // En production, désactiver les fonctionnalités expérimentales par défaut\n      const productionOverrides = {\n        showBetaFeatures: false,\n        enableAIRecommendations: false\n      };\n      \n      // Mais ne pas écraser si explicitement activé via API ou localStorage\n      Object.keys(productionOverrides).forEach(key => {\n        // Vérifier si la valeur a été définie explicitement par l'API ou localStorage\n        if (!this.flagsHistory[key] || this.flagsHistory[key].length === 0) {\n          this.flags[key] = productionOverrides[key];\n        }\n      });\n    }\n    \n    // Activer plus de fonctionnalités en développement pour les tests\n    if (this.environment === ENVIRONMENTS.DEVELOPMENT) {\n      const devOverrides = {\n        showBetaFeatures: true,\n        enablePerformanceMonitoring: true\n      };\n      \n      Object.assign(this.flags, devOverrides);\n    }\n  }\n\n  /**\n   * Charge les flags depuis le localStorage\n   */\n  async loadFlagsFromLocalStorage() {\n    try {\n      const storedFlags = localStorage.getItem('featureFlags');\n      if (storedFlags) {\n        const parsedFlags = JSON.parse(storedFlags);\n        this.flags = { ...this.flags, ...parsedFlags };\n        \n        // Enregistrer la source dans l'historique\n        Object.keys(parsedFlags).forEach(key => {\n          if (!this.flagsHistory[key]) this.flagsHistory[key] = [];\n          this.flagsHistory[key].push({\n            value: parsedFlags[key],\n            timestamp: Date.now(),\n            source: 'localStorage'\n          });\n        });\n      }\n    } catch (error) {\n      console.error('Erreur lors du chargement des feature flags du localStorage:', error);\n    }\n  }\n\n  /**\n   * Récupère les flags depuis l'API\n   * @param {boolean} force Force le rafraîchissement même si le cache est valide\n   */\n  async fetchFlagsFromApi(force = false) {\n    const now = Date.now();\n    \n    // Vérifier si nous devons rafraîchir le cache\n    if (!force && (now - this.lastFetchTime) < this.cacheDuration) {\n      return this.flags;\n    }\n    \n    try {\n      const response = await axios.get('/api/feature-flags', {\n        params: {\n          segment: this.userSegment,\n          environment: this.environment\n        }\n      });\n      \n      if (response.data && response.data.flags) {\n        // Enregistrer les anciennes valeurs pour le tracking des changements\n        const oldFlags = { ...this.flags };\n        \n        // Mettre à jour les flags\n        this.flags = { ...this.flags, ...response.data.flags };\n        this.lastFetchTime = now;\n        \n        // Stocker dans localStorage pour utilisation offline\n        localStorage.setItem('featureFlags', JSON.stringify(this.flags));\n        \n        // Mettre à jour l'historique des changements\n        Object.keys(response.data.flags).forEach(key => {\n          if (!this.flagsHistory[key]) this.flagsHistory[key] = [];\n          this.flagsHistory[key].push({\n            value: response.data.flags[key],\n            previousValue: oldFlags[key],\n            timestamp: now,\n            source: 'api'\n          });\n        });\n        \n        this.notifySubscribers();\n        this.logFlagChanges(oldFlags, this.flags);\n      }\n    } catch (error) {\n      console.error('Erreur lors de la récupération des feature flags depuis l\\'API:', error);\n      // En cas d'erreur, continuer avec les flags actuels\n    }\n    \n    return this.flags;\n  }\n\n  /**\n   * Journalise les changements de flags pour débogage et analyses\n   * @param {Object} oldFlags Anciens flags\n   * @param {Object} newFlags Nouveaux flags\n   */\n  logFlagChanges(oldFlags, newFlags) {\n    const changes = [];\n    \n    Object.keys(newFlags).forEach(key => {\n      if (oldFlags[key] !== newFlags[key]) {\n        changes.push({\n          flag: key,\n          oldValue: oldFlags[key],\n          newValue: newFlags[key],\n          timestamp: Date.now()\n        });\n      }\n    });\n    \n    if (changes.length > 0) {\n      console.info('Feature Flags mis à jour:', changes);\n      \n      // En développement, afficher une notification visuelle\n      if (this.environment === ENVIRONMENTS.DEVELOPMENT && typeof window !== 'undefined') {\n        // Créer une notification simple pour les développeurs\n        this.showDevNotification(`${changes.length} feature flags mis à jour`);\n      }\n    }\n  }\n\n  /**\n   * Affiche une notification pour les développeurs\n   * @param {string} message Message à afficher\n   */\n  showDevNotification(message) {\n    if (typeof document === 'undefined') return;\n    \n    const notificationId = 'feature-flag-notification';\n    let notification = document.getElementById(notificationId);\n    \n    // Créer l'élément s'il n'existe pas\n    if (!notification) {\n      notification = document.createElement('div');\n      notification.id = notificationId;\n      notification.style.position = 'fixed';\n      notification.style.bottom = '20px';\n      notification.style.right = '20px';\n      notification.style.padding = '10px 15px';\n      notification.style.backgroundColor = '#333';\n      notification.style.color = 'white';\n      notification.style.borderRadius = '4px';\n      notification.style.zIndex = '9999';\n      notification.style.opacity = '0';\n      notification.style.transition = 'opacity 0.3s ease-in-out';\n      document.body.appendChild(notification);\n    }\n    \n    // Mettre à jour le contenu\n    notification.textContent = message;\n    notification.style.opacity = '1';\n    \n    // Faire disparaître après 3 secondes\n    setTimeout(() => {\n      notification.style.opacity = '0';\n      setTimeout(() => {\n        if (notification.parentNode) {\n          notification.parentNode.removeChild(notification);\n        }\n      }, 300);\n    }, 3000);\n  }\n\n  /**\n   * Met à jour un ou plusieurs feature flags\n   * @param {Object} flagUpdates Objet contenant les flags à mettre à jour\n   * @param {boolean} persistToServer Si vrai, envoie les modifications au serveur\n   * @returns {Promise<Object>} Les feature flags mis à jour\n   */\n  async updateFlags(flagUpdates, persistToServer = true) {\n    // Enregistrer les anciennes valeurs\n    const oldFlags = { ...this.flags };\n    \n    // Mettre à jour les flags localement\n    this.flags = { ...this.flags, ...flagUpdates };\n    \n    // Stocker dans localStorage\n    localStorage.setItem('featureFlags', JSON.stringify(this.flags));\n    \n    // Mettre à jour l'historique\n    Object.keys(flagUpdates).forEach(key => {\n      if (!this.flagsHistory[key]) this.flagsHistory[key] = [];\n      this.flagsHistory[key].push({\n        value: flagUpdates[key],\n        previousValue: oldFlags[key],\n        timestamp: Date.now(),\n        source: 'manual_update'\n      });\n    });\n    \n    // Journaliser les changements\n    this.logFlagChanges(oldFlags, this.flags);\n    \n    // Notifier les abonnés\n    this.notifySubscribers();\n    \n    // Persister sur le serveur si demandé\n    if (persistToServer) {\n      try {\n        await axios.post('/api/feature-flags', { \n          flags: flagUpdates,\n          segment: this.userSegment,\n          environment: this.environment\n        });\n      } catch (error) {\n        console.error('Erreur lors de la mise à jour des feature flags sur le serveur:', error);\n      }\n    }\n    \n    return this.flags;\n  }\n\n  /**\n   * Vérifie si un feature flag est activé\n   * @param {string} flagName Nom du flag à vérifier\n   * @returns {boolean} Statut du flag (true = activé)\n   */\n  isEnabled(flagName) {\n    // Si le flag n'existe pas, retourner false\n    if (!(flagName in this.flags)) {\n      console.warn(`Feature flag \"${flagName}\" non trouvé`);\n      return false;\n    }\n    \n    return this.flags[flagName] === true;\n  }\n\n  /**\n   * Récupère la valeur d'un flag pour les tests A/B ou les flags multi-valeurs\n   * @param {string} flagName Nom du flag\n   * @param {any} defaultValue Valeur par défaut si le flag n'existe pas\n   * @returns {any} Valeur du flag ou valeur par défaut\n   */\n  getVariant(flagName, defaultValue = null) {\n    if (!(flagName in this.flags)) {\n      console.warn(`Feature flag variant \"${flagName}\" non trouvé`);\n      return defaultValue;\n    }\n    \n    return this.flags[flagName];\n  }\n\n  /**\n   * S'abonne aux changements de feature flags\n   * @param {Function} callback Fonction appelée lors d'un changement\n   * @returns {Function} Fonction pour se désabonner\n   */\n  subscribe(callback) {\n    this.subscribers.push(callback);\n    \n    // Retourner une fonction de nettoyage pour le désabonnement\n    return () => {\n      this.subscribers = this.subscribers.filter(sub => sub !== callback);\n    };\n  }\n\n  /**\n   * Notifie tous les abonnés d'un changement de flags\n   */\n  notifySubscribers() {\n    this.subscribers.forEach(callback => {\n      try {\n        callback(this.flags);\n      } catch (error) {\n        console.error('Erreur lors de la notification d\\'un abonné aux feature flags:', error);\n      }\n    });\n  }\n\n  /**\n   * Récupère l'historique des changements pour un flag\n   * @param {string} flagName Nom du flag\n   * @returns {Array} Historique des changements\n   */\n  getFlagHistory(flagName) {\n    return this.flagsHistory[flagName] || [];\n  }\n\n  /**\n   * Définit la durée du cache\n   * @param {number} durationMs Durée en milliseconds\n   */\n  setCacheDuration(durationMs) {\n    this.cacheDuration = durationMs;\n  }\n}\n\n// Créer une instance singleton du service\nconst featureFlagsService = new FeatureFlagsService();\n\n/**\n * Hook React pour utiliser les feature flags dans les composants\n * @returns {Object} Objet contenant les flags et fonctions utilitaires\n */\nexport const useFeatureFlags = () => {\n  const context = useContext(FeatureFlagsContext);\n  \n  if (!context) {\n    throw new Error('useFeatureFlags doit être utilisé à l\\'intérieur d\\'un FeatureFlagsProvider');\n  }\n  \n  return context;\n};\n\n/**\n * Fournisseur de contexte pour les feature flags\n * @param {Object} props Props du composant\n * @param {React.ReactNode} props.children Enfants du composant\n */\nexport const FeatureFlagsProvider = ({ children }) => {\n  const [flags, setFlags] = useState(DEFAULT_FLAGS);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Charger les flags au montage du composant\n  useEffect(() => {\n    const initializeFlags = async () => {\n      try {\n        setIsLoading(true);\n        await featureFlagsService.initialize();\n        setFlags({ ...featureFlagsService.flags });\n        setError(null);\n      } catch (err) {\n        setError(err.message || 'Erreur lors du chargement des feature flags');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeFlags();\n\n    // S'abonner aux changements\n    const unsubscribe = featureFlagsService.subscribe(updatedFlags => {\n      setFlags({ ...updatedFlags });\n    });\n\n    // Se désabonner lors du démontage\n    return unsubscribe;\n  }, []);\n\n  // Fonction pour mettre à jour un flag\n  const updateFlag = async (flagName, value, persistToServer = true) => {\n    try {\n      await featureFlagsService.updateFlags({ [flagName]: value }, persistToServer);\n    } catch (err) {\n      setError(err.message || 'Erreur lors de la mise à jour du feature flag');\n    }\n  };\n\n  // Fonction pour rafraîchir tous les flags\n  const refreshFlags = async () => {\n    try {\n      setIsLoading(true);\n      await featureFlagsService.fetchFlagsFromApi(true);\n      setFlags({ ...featureFlagsService.flags });\n      setError(null);\n    } catch (err) {\n      setError(err.message || 'Erreur lors du rafraîchissement des feature flags');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Fonction pour vérifier si un flag est activé (raccourci)\n  const isEnabled = (flagName) => {\n    return featureFlagsService.isEnabled(flagName);\n  };\n\n  // Fonction pour récupérer la valeur d'un flag variant\n  const getVariant = (flagName, defaultValue = null) => {\n    return featureFlagsService.getVariant(flagName, defaultValue);\n  };\n\n  const value = {\n    flags,\n    isLoading,\n    error,\n    updateFlag,\n    refreshFlags,\n    isEnabled,\n    getVariant\n  };\n\n  return (\n    <FeatureFlagsContext.Provider value={value}>\n      {children}\n    </FeatureFlagsContext.Provider>\n  );\n};\n\n// Exporter le service pour une utilisation directe si nécessaire\nexport default featureFlagsService;\n","import React, { useState, useEffect, createContext, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport { Alert, Toast, ToastContainer } from 'react-bootstrap';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { \n  faCheckCircle, faExclamationTriangle, \n  faExclamationCircle, faInfoCircle, \n  faTimes \n} from '@fortawesome/free-solid-svg-icons';\n\n// Contexte pour la gestion des notifications\nconst NotificationContext = createContext();\n\n/**\n * Provider pour le système de notification\n * Permet de gérer les notifications à travers l'application\n */\nexport const NotificationProvider = ({ children }) => {\n  const [notifications, setNotifications] = useState([]);\n\n  // Ajouter une nouvelle notification\n  const addNotification = (notification) => {\n    const id = Date.now().toString();\n    const defaultDuration = notification.type === 'error' ? 8000 : 5000;\n    \n    setNotifications(prev => [\n      ...prev,\n      {\n        id,\n        type: 'info',\n        title: '',\n        message: '',\n        duration: defaultDuration,\n        ...notification,\n        timestamp: new Date()\n      }\n    ]);\n    \n    // Enregistrer les erreurs dans la console pour le débogage\n    if (notification.type === 'error') {\n      console.error(`Notification d'erreur: ${notification.title || ''} - ${notification.message || ''}`, \n                    notification.error || '');\n    }\n    \n    return id;\n  };\n\n  // Supprimer une notification par ID\n  const removeNotification = (id) => {\n    setNotifications(prev => prev.filter(notif => notif.id !== id));\n  };\n\n  // Méthodes d'utilitaire pour différents types de notifications\n  const notify = {\n    success: (message, options = {}) => addNotification({ \n      type: 'success', message, ...options \n    }),\n    \n    error: (message, error = null, options = {}) => {\n      // Extraire le message d'erreur si un objet Error est fourni\n      let errorMessage = message;\n      if (error && typeof error === 'object') {\n        if (error.message) {\n          errorMessage = `${message}: ${error.message}`;\n        }\n        \n        // Enregistrer l'erreur complète dans la console\n        console.error('Détails de l\\'erreur:', error);\n      }\n      \n      return addNotification({ \n        type: 'error', \n        message: errorMessage, \n        error,\n        ...options \n      });\n    },\n    \n    warning: (message, options = {}) => addNotification({ \n      type: 'warning', message, ...options \n    }),\n    \n    info: (message, options = {}) => addNotification({ \n      type: 'info', message, ...options \n    })\n  };\n\n  // Auto-supprimer les notifications après leur durée\n  useEffect(() => {\n    const timers = notifications.map(notification => {\n      if (notification.duration) {\n        return setTimeout(() => {\n          removeNotification(notification.id);\n        }, notification.duration);\n      }\n      return null;\n    }).filter(Boolean);\n\n    return () => {\n      timers.forEach(timer => clearTimeout(timer));\n    };\n  }, [notifications]);\n\n  return (\n    <NotificationContext.Provider value={{ notifications, addNotification, removeNotification, notify }}>\n      {children}\n      <NotificationDisplay />\n    </NotificationContext.Provider>\n  );\n};\n\nNotificationProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\n/**\n * Hook pour utiliser le système de notification\n */\nexport const useNotification = () => {\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotification doit être utilisé à l\\'intérieur d\\'un NotificationProvider');\n  }\n  return context;\n};\n\n/**\n * Composant d'affichage des notifications\n */\nconst NotificationDisplay = () => {\n  const { notifications, removeNotification } = useContext(NotificationContext);\n\n  // Obtenir l'icône correspondant au type de notification\n  const getIcon = (type) => {\n    switch (type) {\n      case 'success':\n        return faCheckCircle;\n      case 'error':\n        return faExclamationCircle;\n      case 'warning':\n        return faExclamationTriangle;\n      case 'info':\n      default:\n        return faInfoCircle;\n    }\n  };\n\n  return (\n    <>\n      {/* Notifications en bas à droite pour les messages de statut */}\n      <ToastContainer position=\"bottom-end\" className=\"p-3\" style={{ zIndex: 1100 }}>\n        {notifications\n          .filter(notification => notification.type !== 'error')\n          .map(notification => (\n            <Toast \n              key={notification.id}\n              onClose={() => removeNotification(notification.id)}\n              bg={notification.type === 'info' ? 'light' : notification.type}\n              text={notification.type === 'info' ? 'dark' : 'white'}\n              delay={notification.duration}\n              autohide\n            >\n              <Toast.Header>\n                <FontAwesomeIcon icon={getIcon(notification.type)} className=\"me-2\" />\n                <strong className=\"me-auto\">\n                  {notification.title || \n                  (notification.type === 'success' ? 'Succès' : \n                   notification.type === 'warning' ? 'Attention' : 'Information')}\n                </strong>\n                <small>{notification.timestamp?.toLocaleTimeString()}</small>\n              </Toast.Header>\n              <Toast.Body>\n                {notification.message}\n              </Toast.Body>\n            </Toast>\n          ))}\n      </ToastContainer>\n\n      {/* Alertes centrées pour les erreurs importantes */}\n      <div className=\"notification-alerts-container\" style={{ \n        position: 'fixed', \n        top: '20px', \n        left: '50%', \n        transform: 'translateX(-50%)',\n        zIndex: 1100,\n        maxWidth: '90%',\n        width: '500px'\n      }}>\n        {notifications\n          .filter(notification => notification.type === 'error')\n          .map(notification => (\n            <Alert \n              key={notification.id} \n              variant=\"danger\" \n              dismissible\n              onClose={() => removeNotification(notification.id)}\n              className=\"mb-3 shadow-sm\"\n            >\n              <div className=\"d-flex align-items-center\">\n                <FontAwesomeIcon icon={faExclamationCircle} className=\"me-2\" size=\"lg\" />\n                <div>\n                  <Alert.Heading>{notification.title || 'Erreur'}</Alert.Heading>\n                  <p className=\"mb-0\">{notification.message}</p>\n                </div>\n              </div>\n              {notification.details && (\n                <div className=\"mt-2 pt-2 border-top\">\n                  <small className=\"text-muted\">{notification.details}</small>\n                </div>\n              )}\n            </Alert>\n          ))}\n      </div>\n    </>\n  );\n};\n\n/**\n * Composant d'alerte\n */\nexport const Notification = ({ type, title, message, onClose, dismissible = true }) => {\n  return (\n    <Alert variant={type} dismissible={dismissible} onClose={onClose}>\n      {title && <Alert.Heading>{title}</Alert.Heading>}\n      <p className=\"mb-0\">{message}</p>\n    </Alert>\n  );\n};\n\nNotification.propTypes = {\n  type: PropTypes.oneOf(['success', 'info', 'warning', 'error', 'danger']),\n  title: PropTypes.string,\n  message: PropTypes.string.isRequired,\n  onClose: PropTypes.func,\n  dismissible: PropTypes.bool\n};\n\nexport default NotificationProvider;\n","import React, { createContext, useState, useContext, useEffect } from 'react';\nimport { format } from 'date-fns';\nimport { fr } from 'date-fns/locale';\nimport { useNotification } from '../components/common/NotificationSystem';\nimport { useFeatureFlags } from '../services/featureFlags';\n\n// Création du contexte\nexport const CommunityContext = createContext();\n\n// Hook personnalisé pour utiliser le contexte\nexport const useCommunity = () => {\n  const context = useContext(CommunityContext);\n  if (!context) {\n    throw new Error('useCommunity doit être utilisé à l\\'intérieur d\\'un CommunityProvider');\n  }\n  return context;\n};\n\n// Données de démonstration\nconst mockUserProfile = {\n  id: '123',\n  username: 'cycliste_passionné',\n  fullName: 'Jean Dupont',\n  following: 145,\n  followers: 89,\n  achievementCount: 27,\n  points: 3450,\n  level: 7,\n  region: 'Alsace',\n  avatar: '/images/profiles/default-avatar.jpg',\n};\n\nconst mockCommunityStats = {\n  totalMembers: 5432,\n  activeMembers: 1284,\n  yourRank: 172,\n  activeChallenges: 14,\n  yourChallenges: 5,\n  totalChallenges: 48,\n  regionRiders: 412,\n  weeklyActivity: [35, 42, 28, 45, 51, 63, 47],\n};\n\nconst mockUpcomingEvents = [\n  {\n    id: '1',\n    title: 'Randonnée Col de la Schlucht',\n    date: '2025-04-18',\n    time: '09:00',\n    location: 'Munster, Haut-Rhin',\n    distance: 95,\n    elevation: 1200,\n    participants: 47,\n    organizer: 'Club Cycliste du Haut-Rhin',\n    joined: true,\n    description: 'Randonnée cycliste à travers la vallée de Munster et montée du Col de la Schlucht.'\n  },\n  {\n    id: '2',\n    title: 'Montée du Grand Ballon',\n    date: '2025-05-02',\n    time: '10:30',\n    location: 'Thann, Haut-Rhin',\n    distance: 75,\n    elevation: 1424,\n    participants: 32,\n    organizer: 'Cyclomontagnards d\\'Alsace',\n    joined: false,\n    description: 'Défi d\\'ascension du Grand Ballon, le point culminant des Vosges.'\n  },\n  {\n    id: '3',\n    title: 'Boucle des Trois Frontières',\n    date: '2025-05-15',\n    time: '08:00',\n    location: 'Saint-Louis, Haut-Rhin',\n    distance: 110,\n    elevation: 850,\n    participants: 28,\n    organizer: 'Vélo Club Transfrontalier',\n    joined: false,\n    description: 'Parcours à travers la France, l\\'Allemagne et la Suisse avec découverte de paysages variés.'\n  }\n];\n\n// Composant Provider qui fournit le contexte\nexport const CommunityProvider = ({ children }) => {\n  // Systèmes externes\n  const { notify } = useNotification();\n  const { isEnabled } = useFeatureFlags();\n  \n  // États\n  const [userProfile, setUserProfile] = useState(mockUserProfile);\n  const [communityStats, setCommunityStats] = useState(mockCommunityStats);\n  const [upcomingEvents, setUpcomingEvents] = useState(mockUpcomingEvents);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Effet pour charger les données (simulation)\n  useEffect(() => {\n    // Dans une application réelle, charger les données depuis l'API\n    setLoading(true);\n    \n    try {\n      // Simuler un délai de chargement\n      const timer = setTimeout(() => {\n        setUserProfile(mockUserProfile);\n        setCommunityStats(mockCommunityStats);\n        \n        // Vérifier si les défis mensuels sont activés via feature flag\n        if (isEnabled('enableMonthlyChallenge')) {\n          setUpcomingEvents(mockUpcomingEvents);\n        } else {\n          // Si le feature flag est désactivé, filtrer les défis mensuels\n          setUpcomingEvents(mockUpcomingEvents.filter(event => !event.title.includes('Mensuel')));\n        }\n        \n        setLoading(false);\n      }, 800);\n      \n      return () => clearTimeout(timer);\n    } catch (error) {\n      setError(error);\n      setLoading(false);\n      notify.error('Erreur lors du chargement des données communautaires', error);\n    }\n  }, [notify, isEnabled]);\n\n  // Fonction pour formater une date\n  const formatDate = (dateString) => {\n    try {\n      const date = new Date(dateString);\n      return format(date, 'dd MMM yyyy', { locale: fr });\n    } catch (error) {\n      console.error('Error formatting date:', error);\n      notify.error('Erreur lors du formatage de la date', error);\n      return dateString;\n    }\n  };\n\n  // Fonction pour rejoindre un événement\n  const handleJoinEvent = (eventId) => {\n    try {\n      setUpcomingEvents(prevEvents => \n        prevEvents.map(event => \n          event.id === eventId \n            ? { ...event, joined: true } \n            : event\n        )\n      );\n      notify.success(`Vous avez rejoint l'événement avec succès`);\n    } catch (error) {\n      notify.error('Impossible de rejoindre l\\'événement', error);\n    }\n  };\n\n  // Fonction pour quitter un événement\n  const handleLeaveEvent = (eventId) => {\n    try {\n      setUpcomingEvents(prevEvents => \n        prevEvents.map(event => \n          event.id === eventId \n            ? { ...event, joined: false } \n            : event\n        )\n      );\n      notify.info(`Vous avez quitté l'événement`);\n    } catch (error) {\n      notify.error('Impossible de quitter l\\'événement', error);\n    }\n  };\n\n  // Valeur du contexte à exposer\n  const value = {\n    userProfile,\n    communityStats,\n    upcomingEvents,\n    loading,\n    error,\n    formatDate,\n    handleJoinEvent,\n    handleLeaveEvent,\n    // Exposer les fonctions externes\n    isFeatureEnabled: isEnabled\n  };\n\n  return (\n    <CommunityContext.Provider value={value}>\n      {children}\n    </CommunityContext.Provider>\n  );\n};\n\nexport default CommunityProvider;\n"],"names":["DEFAULT_FLAGS","enableDarkMode","showBetaFeatures","useNewNavigation","enableSevenMajorsChallenge","enableMonthlyChallenge","enableSocialSharing","enableApiCaching","enablePerformanceMonitoring","enable3DColVisualization","enableProgressiveLoading3D","enableAIRecommendations","enableRealTimeWeather","enableAdvancedCaching","enableOfflineMode","enableLazyLoadingImages","enableAdvancedMetrics","enableBulkOperations","enableNutritionPlanner","enableMealSuggestions","enableColSpecificNutrition","enableTrainingPrograms","enablePerformanceAnalytics","enableColSpecificTraining","enableMountainModule","enableRegionalTrainingPlans","ENVIRONMENTS","FeatureFlagsContext","createContext","flags","isLoading","error","updateFlag","refreshFlags","isEnabled","getVariant","featureFlagsService","constructor","this","subscribers","isInitialized","lastFetchTime","cacheDuration","environment","process","userSegment","flagsHistory","initialize","determineUserSegment","loadFlagsFromLocalStorage","fetchFlagsFromApi","applyEnvironmentOverrides","Object","keys","forEach","key","value","timestamp","Date","now","source","notifySubscribers","console","userInfo","JSON","parse","localStorage","getItem","role","visits","registeredAt","registrationDate","oneMonthAgo","setMonth","getMonth","productionOverrides","length","devOverrides","assign","storedFlags","parsedFlags","push","force","arguments","undefined","response","axios","get","params","segment","data","oldFlags","setItem","stringify","previousValue","logFlagChanges","newFlags","changes","flag","oldValue","newValue","info","window","showDevNotification","message","document","notificationId","notification","getElementById","createElement","id","style","position","bottom","right","padding","backgroundColor","color","borderRadius","zIndex","opacity","transition","body","appendChild","textContent","setTimeout","parentNode","removeChild","updateFlags","flagUpdates","persistToServer","post","flagName","warn","defaultValue","subscribe","callback","filter","sub","getFlagHistory","setCacheDuration","durationMs","useFeatureFlags","context","useContext","Error","NotificationContext","useNotification","CommunityContext","useCommunity"],"sourceRoot":""}