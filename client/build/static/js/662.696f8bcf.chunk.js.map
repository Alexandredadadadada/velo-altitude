{"version":3,"file":"static/js/662.696f8bcf.chunk.js","mappings":"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","sources":["components/common/NotificationSystem.js","services/errorService.js","hooks/useErrorHandler.js","components/common/Breadcrumbs.js","services/api.js"],"sourcesContent":["import React, { useState, useEffect, createContext, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport { Alert, Toast, ToastContainer } from 'react-bootstrap';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { \n  faCheckCircle, faExclamationTriangle, \n  faExclamationCircle, faInfoCircle, \n  faTimes \n} from '@fortawesome/free-solid-svg-icons';\n\n// Contexte pour la gestion des notifications\nconst NotificationContext = createContext();\n\n/**\n * Provider pour le système de notification\n * Permet de gérer les notifications à travers l'application\n */\nexport const NotificationProvider = ({ children }) => {\n  const [notifications, setNotifications] = useState([]);\n\n  // Ajouter une nouvelle notification\n  const addNotification = (notification) => {\n    const id = Date.now().toString();\n    const defaultDuration = notification.type === 'error' ? 8000 : 5000;\n    \n    setNotifications(prev => [\n      ...prev,\n      {\n        id,\n        type: 'info',\n        title: '',\n        message: '',\n        duration: defaultDuration,\n        ...notification,\n        timestamp: new Date()\n      }\n    ]);\n    \n    // Enregistrer les erreurs dans la console pour le débogage\n    if (notification.type === 'error') {\n      console.error(`Notification d'erreur: ${notification.title || ''} - ${notification.message || ''}`, \n                    notification.error || '');\n    }\n    \n    return id;\n  };\n\n  // Supprimer une notification par ID\n  const removeNotification = (id) => {\n    setNotifications(prev => prev.filter(notif => notif.id !== id));\n  };\n\n  // Méthodes d'utilitaire pour différents types de notifications\n  const notify = {\n    success: (message, options = {}) => addNotification({ \n      type: 'success', message, ...options \n    }),\n    \n    error: (message, error = null, options = {}) => {\n      // Extraire le message d'erreur si un objet Error est fourni\n      let errorMessage = message;\n      if (error && typeof error === 'object') {\n        if (error.message) {\n          errorMessage = `${message}: ${error.message}`;\n        }\n        \n        // Enregistrer l'erreur complète dans la console\n        console.error('Détails de l\\'erreur:', error);\n      }\n      \n      return addNotification({ \n        type: 'error', \n        message: errorMessage, \n        error,\n        ...options \n      });\n    },\n    \n    warning: (message, options = {}) => addNotification({ \n      type: 'warning', message, ...options \n    }),\n    \n    info: (message, options = {}) => addNotification({ \n      type: 'info', message, ...options \n    })\n  };\n\n  // Auto-supprimer les notifications après leur durée\n  useEffect(() => {\n    const timers = notifications.map(notification => {\n      if (notification.duration) {\n        return setTimeout(() => {\n          removeNotification(notification.id);\n        }, notification.duration);\n      }\n      return null;\n    }).filter(Boolean);\n\n    return () => {\n      timers.forEach(timer => clearTimeout(timer));\n    };\n  }, [notifications]);\n\n  return (\n    <NotificationContext.Provider value={{ notifications, addNotification, removeNotification, notify }}>\n      {children}\n      <NotificationDisplay />\n    </NotificationContext.Provider>\n  );\n};\n\nNotificationProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\n/**\n * Hook pour utiliser le système de notification\n */\nexport const useNotification = () => {\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotification doit être utilisé à l\\'intérieur d\\'un NotificationProvider');\n  }\n  return context;\n};\n\n/**\n * Composant d'affichage des notifications\n */\nconst NotificationDisplay = () => {\n  const { notifications, removeNotification } = useContext(NotificationContext);\n\n  // Obtenir l'icône correspondant au type de notification\n  const getIcon = (type) => {\n    switch (type) {\n      case 'success':\n        return faCheckCircle;\n      case 'error':\n        return faExclamationCircle;\n      case 'warning':\n        return faExclamationTriangle;\n      case 'info':\n      default:\n        return faInfoCircle;\n    }\n  };\n\n  return (\n    <>\n      {/* Notifications en bas à droite pour les messages de statut */}\n      <ToastContainer position=\"bottom-end\" className=\"p-3\" style={{ zIndex: 1100 }}>\n        {notifications\n          .filter(notification => notification.type !== 'error')\n          .map(notification => (\n            <Toast \n              key={notification.id}\n              onClose={() => removeNotification(notification.id)}\n              bg={notification.type === 'info' ? 'light' : notification.type}\n              text={notification.type === 'info' ? 'dark' : 'white'}\n              delay={notification.duration}\n              autohide\n            >\n              <Toast.Header>\n                <FontAwesomeIcon icon={getIcon(notification.type)} className=\"me-2\" />\n                <strong className=\"me-auto\">\n                  {notification.title || \n                  (notification.type === 'success' ? 'Succès' : \n                   notification.type === 'warning' ? 'Attention' : 'Information')}\n                </strong>\n                <small>{notification.timestamp?.toLocaleTimeString()}</small>\n              </Toast.Header>\n              <Toast.Body>\n                {notification.message}\n              </Toast.Body>\n            </Toast>\n          ))}\n      </ToastContainer>\n\n      {/* Alertes centrées pour les erreurs importantes */}\n      <div className=\"notification-alerts-container\" style={{ \n        position: 'fixed', \n        top: '20px', \n        left: '50%', \n        transform: 'translateX(-50%)',\n        zIndex: 1100,\n        maxWidth: '90%',\n        width: '500px'\n      }}>\n        {notifications\n          .filter(notification => notification.type === 'error')\n          .map(notification => (\n            <Alert \n              key={notification.id} \n              variant=\"danger\" \n              dismissible\n              onClose={() => removeNotification(notification.id)}\n              className=\"mb-3 shadow-sm\"\n            >\n              <div className=\"d-flex align-items-center\">\n                <FontAwesomeIcon icon={faExclamationCircle} className=\"me-2\" size=\"lg\" />\n                <div>\n                  <Alert.Heading>{notification.title || 'Erreur'}</Alert.Heading>\n                  <p className=\"mb-0\">{notification.message}</p>\n                </div>\n              </div>\n              {notification.details && (\n                <div className=\"mt-2 pt-2 border-top\">\n                  <small className=\"text-muted\">{notification.details}</small>\n                </div>\n              )}\n            </Alert>\n          ))}\n      </div>\n    </>\n  );\n};\n\n/**\n * Composant d'alerte\n */\nexport const Notification = ({ type, title, message, onClose, dismissible = true }) => {\n  return (\n    <Alert variant={type} dismissible={dismissible} onClose={onClose}>\n      {title && <Alert.Heading>{title}</Alert.Heading>}\n      <p className=\"mb-0\">{message}</p>\n    </Alert>\n  );\n};\n\nNotification.propTypes = {\n  type: PropTypes.oneOf(['success', 'info', 'warning', 'error', 'danger']),\n  title: PropTypes.string,\n  message: PropTypes.string.isRequired,\n  onClose: PropTypes.func,\n  dismissible: PropTypes.bool\n};\n\nexport default NotificationProvider;\n","/**\n * Service de gestion des erreurs côté client\n * Ce service fait le pont entre le système de notification et la gestion des erreurs API\n * Il assure une gestion cohérente des erreurs à travers l'application\n */\n\nimport { api } from './api';\n\n// Mapping des types d'erreurs du backend vers les types de notifications frontend\nconst ERROR_TYPE_MAPPING = {\n  // Erreurs d'authentification\n  'auth_token_expired': { type: 'error', title: 'Session expirée', severity: 'warning' },\n  'auth_token_invalid': { type: 'error', title: 'Authentification invalide', severity: 'warning' },\n  'auth_token_missing': { type: 'error', title: 'Authentification requise', severity: 'warning' },\n  'auth_token_revoked': { type: 'error', title: 'Session révoquée', severity: 'warning' },\n  'auth_credentials_invalid': { type: 'error', title: 'Identifiants invalides', severity: 'warning' },\n  \n  // Erreurs de validation\n  'validation_error': { type: 'warning', title: 'Données invalides', severity: 'warning' },\n  'invalid_input': { type: 'warning', title: 'Saisie invalide', severity: 'warning' },\n  'missing_required_field': { type: 'warning', title: 'Champ requis manquant', severity: 'warning' },\n  \n  // Erreurs de ressources\n  'resource_not_found': { type: 'error', title: 'Ressource introuvable', severity: 'warning' },\n  'route_not_found': { type: 'error', title: 'Page introuvable', severity: 'warning' },\n  'resource_conflict': { type: 'error', title: 'Conflit de ressources', severity: 'warning' },\n  'resource_exists': { type: 'warning', title: 'Ressource existante', severity: 'info' },\n  \n  // Erreurs de permissions\n  'permission_denied': { type: 'error', title: 'Accès refusé', severity: 'warning' },\n  'insufficient_permissions': { type: 'error', title: 'Permissions insuffisantes', severity: 'warning' },\n  \n  // Erreurs de serveur\n  'server_error': { type: 'error', title: 'Erreur serveur', severity: 'critical' },\n  'database_error': { type: 'error', title: 'Erreur de base de données', severity: 'critical' },\n  'service_unavailable': { type: 'error', title: 'Service indisponible', severity: 'critical' },\n  \n  // Erreurs de performance\n  'timeout_error': { type: 'error', title: 'Délai d\\'attente dépassé', severity: 'warning' },\n  'rate_limit_exceeded': { type: 'warning', title: 'Limite de requêtes dépassée', severity: 'warning' },\n  'performance_issue': { type: 'warning', title: 'Problème de performance', severity: 'info' },\n  \n  // Erreurs de réseau\n  'network_error': { type: 'error', title: 'Erreur réseau', severity: 'warning' },\n  'api_error': { type: 'error', title: 'Erreur API', severity: 'warning' },\n  \n  // Erreur par défaut\n  'default': { type: 'error', title: 'Erreur', severity: 'warning' }\n};\n\n// Configuration des notifications par type d'erreur et sévérité\nconst NOTIFICATION_CONFIG = {\n  critical: {\n    position: 'top-center',\n    autoClose: false,\n    type: 'toast',\n    closeButton: true,\n    pauseOnHover: true\n  },\n  warning: {\n    position: 'top-right',\n    autoClose: 8000,\n    type: 'toast',\n    closeButton: true,\n    pauseOnHover: true\n  },\n  info: {\n    position: 'bottom-right',\n    autoClose: 5000,\n    type: 'toast',\n    closeButton: true,\n    pauseOnHover: true\n  }\n};\n\n/**\n * Classe de service de gestion des erreurs\n */\nclass ErrorService {\n  constructor() {\n    this.notifyFn = null;\n    this.errorStats = {\n      count: 0,\n      byType: {},\n      byEndpoint: {}\n    };\n    \n    // Configurer l'intercepteur de réponse pour capturer les erreurs API\n    this.setupApiInterceptor();\n  }\n  \n  /**\n   * Initialiser le service avec la fonction de notification\n   * @param {Function} notifyFn - Fonction de notification du contexte NotificationContext\n   */\n  init(notifyFn) {\n    this.notifyFn = notifyFn;\n    console.log('Service d\\'erreur initialisé avec le système de notification');\n  }\n  \n  /**\n   * Configurer l'intercepteur API pour capturer et traiter les erreurs\n   */\n  setupApiInterceptor() {\n    api.interceptors.response.use(\n      response => response,\n      error => {\n        this.handleApiError(error);\n        return Promise.reject(error);\n      }\n    );\n  }\n  \n  /**\n   * Gérer une erreur API\n   * @param {Error} error - L'erreur Axios\n   */\n  handleApiError(error) {\n    // Extraire les informations d'erreur de la réponse\n    let errorData = {\n      type: 'network_error',\n      message: 'Erreur de connexion au serveur',\n      severity: 'warning',\n      details: error.message\n    };\n    \n    // Récupérer les détails d'erreur si disponibles dans la réponse\n    if (error.response && error.response.data) {\n      const { data } = error.response;\n      \n      if (data.error) {\n        errorData = {\n          type: data.error.type || errorData.type,\n          message: data.error.message || errorData.message,\n          severity: data.error.severity || errorData.severity,\n          details: data.error.details || errorData.details,\n          notification: data.error.notification || null\n        };\n      }\n    }\n    \n    // Mettre à jour les statistiques d'erreur\n    this.trackError(errorData, error);\n    \n    // Notifier l'utilisateur si la fonction de notification est disponible\n    this.notifyError(errorData);\n    \n    return errorData;\n  }\n  \n  /**\n   * Suivre les statistiques d'erreur\n   * @param {Object} errorData - Données d'erreur\n   * @param {Error} originalError - Erreur originale\n   */\n  trackError(errorData, originalError) {\n    this.errorStats.count++;\n    \n    // Suivre par type\n    if (!this.errorStats.byType[errorData.type]) {\n      this.errorStats.byType[errorData.type] = 0;\n    }\n    this.errorStats.byType[errorData.type]++;\n    \n    // Suivre par endpoint si disponible\n    if (originalError.config && originalError.config.url) {\n      const endpoint = originalError.config.url;\n      if (!this.errorStats.byEndpoint[endpoint]) {\n        this.errorStats.byEndpoint[endpoint] = 0;\n      }\n      this.errorStats.byEndpoint[endpoint]++;\n    }\n    \n    // Envoyer les statistiques au serveur périodiquement (à implémenter)\n  }\n  \n  /**\n   * Notifier l'utilisateur d'une erreur\n   * @param {Object} errorData - Données d'erreur\n   */\n  notifyError(errorData) {\n    if (!this.notifyFn) {\n      console.warn('Système de notification non initialisé, impossible d\\'afficher l\\'erreur');\n      return;\n    }\n    \n    // Obtenir la configuration de notification en fonction du type d'erreur\n    const errorTypeConfig = ERROR_TYPE_MAPPING[errorData.type] || ERROR_TYPE_MAPPING.default;\n    const severityConfig = NOTIFICATION_CONFIG[errorData.severity] || NOTIFICATION_CONFIG.warning;\n    \n    // Utiliser la configuration de notification personnalisée si fournie par le backend\n    const notificationConfig = errorData.notification || {};\n    \n    // Créer la notification\n    this.notifyFn.error(\n      errorData.message,\n      null,\n      {\n        title: errorTypeConfig.title,\n        details: process.env.NODE_ENV !== 'production' ? errorData.details : undefined,\n        duration: notificationConfig.autoClose || severityConfig.autoClose,\n        ...notificationConfig\n      }\n    );\n  }\n  \n  /**\n   * Gérer une erreur manuelle (non liée à une requête API)\n   * @param {string} message - Message d'erreur\n   * @param {string} type - Type d'erreur\n   * @param {Object} options - Options supplémentaires\n   */\n  handleError(message, type = 'default', options = {}) {\n    const errorData = {\n      type,\n      message,\n      severity: options.severity || 'warning',\n      details: options.details || '',\n      notification: options.notification || null\n    };\n    \n    this.trackError(errorData, new Error(message));\n    this.notifyError(errorData);\n    \n    return errorData;\n  }\n  \n  /**\n   * Obtenir les statistiques d'erreur\n   * @returns {Object} Statistiques d'erreur\n   */\n  getErrorStats() {\n    return { ...this.errorStats };\n  }\n  \n  /**\n   * Réinitialiser les statistiques d'erreur\n   */\n  resetErrorStats() {\n    this.errorStats = {\n      count: 0,\n      byType: {},\n      byEndpoint: {}\n    };\n  }\n}\n\n// Créer et exporter une instance singleton\nconst errorService = new ErrorService();\n\nexport default errorService;\n","/**\n * Hook personnalisé pour la gestion des erreurs\n * Ce hook combine le service d'erreur et le système de notification\n * pour fournir une gestion cohérente des erreurs dans les composants\n */\n\nimport { useEffect, useCallback } from 'react';\nimport { useNotification } from '../components/common/NotificationSystem';\nimport errorService from '../services/errorService';\n\n/**\n * Hook pour la gestion des erreurs\n * @returns {Object} Fonctions et utilitaires pour la gestion des erreurs\n */\nconst useErrorHandler = () => {\n  const { notify } = useNotification();\n  \n  // Initialiser le service d'erreur avec le système de notification\n  useEffect(() => {\n    errorService.init(notify);\n  }, [notify]);\n  \n  /**\n   * Fonction pour gérer les erreurs d'API de manière asynchrone\n   * @param {Promise} promise - La promesse à exécuter\n   * @param {Object} options - Options de gestion d'erreur\n   * @returns {Promise} La promesse avec gestion d'erreur\n   */\n  const handleApiRequest = useCallback(async (promise, options = {}) => {\n    const {\n      successMessage,\n      loadingMessage,\n      errorMessage = 'Une erreur est survenue',\n      showSuccess = false,\n      showLoading = false,\n      onSuccess,\n      onError\n    } = options;\n    \n    let loadingId;\n    \n    try {\n      // Afficher un message de chargement si demandé\n      if (showLoading && loadingMessage) {\n        loadingId = notify.info(loadingMessage, { \n          title: 'Chargement', \n          duration: 0 // Pas de fermeture automatique\n        });\n      }\n      \n      // Exécuter la promesse\n      const result = await promise;\n      \n      // Supprimer le message de chargement\n      if (loadingId) {\n        errorService.notifyFn.removeNotification(loadingId);\n      }\n      \n      // Afficher un message de succès si demandé\n      if (showSuccess && successMessage) {\n        notify.success(successMessage);\n      }\n      \n      // Exécuter le callback de succès si fourni\n      if (onSuccess) {\n        onSuccess(result);\n      }\n      \n      return result;\n    } catch (error) {\n      // Supprimer le message de chargement\n      if (loadingId) {\n        errorService.notifyFn.removeNotification(loadingId);\n      }\n      \n      // Utiliser le message d'erreur personnalisé si fourni\n      if (errorMessage) {\n        errorService.handleError(\n          errorMessage, \n          error.response?.data?.error?.type || 'default',\n          { details: error.message }\n        );\n      }\n      \n      // Exécuter le callback d'erreur si fourni\n      if (onError) {\n        onError(error);\n      }\n      \n      throw error;\n    }\n  }, [notify]);\n  \n  /**\n   * Fonction pour gérer les erreurs de manière synchrone (try/catch)\n   * @param {Function} fn - La fonction à exécuter\n   * @param {Object} options - Options de gestion d'erreur\n   * @returns {any} Le résultat de la fonction ou null en cas d'erreur\n   */\n  const tryCatch = useCallback((fn, options = {}) => {\n    const {\n      errorMessage = 'Une erreur est survenue',\n      showError = true,\n      fallbackValue = null,\n      onError\n    } = options;\n    \n    try {\n      return fn();\n    } catch (error) {\n      if (showError) {\n        errorService.handleError(\n          errorMessage, \n          'default',\n          { details: error.message }\n        );\n      }\n      \n      if (onError) {\n        onError(error);\n      }\n      \n      return fallbackValue;\n    }\n  }, []);\n  \n  /**\n   * Fonction pour gérer les erreurs de formulaire\n   * @param {Object} error - L'erreur de validation du formulaire\n   * @param {Function} setError - Fonction pour définir les erreurs dans le formulaire\n   */\n  const handleFormError = useCallback((error, setError) => {\n    // Gérer les erreurs de validation du backend\n    if (error.response?.data?.error?.validationErrors) {\n      const { validationErrors } = error.response.data.error;\n      \n      // Définir les erreurs dans le formulaire\n      Object.entries(validationErrors).forEach(([field, message]) => {\n        setError(field, {\n          type: 'manual',\n          message\n        });\n      });\n      \n      // Afficher un message d'erreur général\n      errorService.handleError(\n        'Veuillez corriger les erreurs dans le formulaire',\n        'validation_error'\n      );\n    } else {\n      // Gérer les autres types d'erreurs\n      errorService.handleApiError(error);\n    }\n  }, []);\n  \n  return {\n    handleApiRequest,\n    tryCatch,\n    handleFormError,\n    handleError: errorService.handleError.bind(errorService),\n    getErrorStats: errorService.getErrorStats.bind(errorService)\n  };\n};\n\nexport default useErrorHandler;\n","import React from 'react';\nimport { Link, useLocation } from 'react-router-dom';\nimport { Breadcrumbs as MUIBreadcrumbs, Typography, Link as MUILink } from '@mui/material';\nimport HomeIcon from '@mui/icons-material/Home';\nimport NavigateNextIcon from '@mui/icons-material/NavigateNext';\nimport DirectionsBikeIcon from '@mui/icons-material/DirectionsBike';\nimport TerrainIcon from '@mui/icons-material/Terrain';\nimport RestaurantIcon from '@mui/icons-material/Restaurant';\nimport MapIcon from '@mui/icons-material/Map';\nimport PeopleIcon from '@mui/icons-material/People';\nimport PersonIcon from '@mui/icons-material/Person';\nimport SettingsIcon from '@mui/icons-material/Settings';\nimport BugReportIcon from '@mui/icons-material/BugReport';\n\n// Configuration des routes pour les breadcrumbs\nconst routeConfig = {\n  '/': { label: 'Accueil', icon: <HomeIcon fontSize=\"small\" /> },\n  '/cols': { label: 'Cols', icon: <TerrainIcon fontSize=\"small\" /> },\n  '/training': { label: 'Entraînement', icon: <DirectionsBikeIcon fontSize=\"small\" /> },\n  '/nutrition': { label: 'Nutrition', icon: <RestaurantIcon fontSize=\"small\" /> },\n  '/routes': { label: 'Parcours', icon: <MapIcon fontSize=\"small\" /> },\n  '/social': { label: 'Communauté', icon: <PeopleIcon fontSize=\"small\" /> },\n  '/profile': { label: 'Profil', icon: <PersonIcon fontSize=\"small\" /> },\n  '/settings': { label: 'Paramètres', icon: <SettingsIcon fontSize=\"small\" /> },\n  '/error-demo': { label: 'Démo Gestion d\\'Erreurs', icon: <BugReportIcon fontSize=\"small\" /> },\n};\n\n// Configuration des segments spécifiques pour les sous-routes\nconst segmentConfig = {\n  'catalog': { label: 'Catalogue' },\n  'explorer': { label: 'Explorateur' },\n  'detail': { label: 'Détails' },\n  'stats': { label: 'Statistiques' },\n  'calendar': { label: 'Calendrier' },\n  'programs': { label: 'Programmes' },\n  'planner': { label: 'Planificateur' },\n  'community': { label: 'Communauté' },\n  'achievements': { label: 'Réussites' }\n};\n\n/**\n * Composant Breadcrumbs pour la navigation hiérarchique\n * Affiche le chemin de navigation actuel avec des liens interactifs\n */\nconst Breadcrumbs = () => {\n  const location = useLocation();\n  const pathnames = location.pathname.split('/').filter(x => x);\n  \n  // Fonction pour générer le libellé à partir d'un segment d'URL\n  const getSegmentLabel = (segment) => {\n    // Vérifier si c'est un segment connu\n    if (segmentConfig[segment]) {\n      return segmentConfig[segment].label;\n    }\n    \n    // Vérifier si c'est un ID numérique ou alphanumérique\n    if (/^\\d+$/.test(segment) || /^[a-zA-Z0-9\\-_]+$/.test(segment)) {\n      return `#${segment}`;\n    }\n    \n    // Formater le segment en titre lisible\n    return segment.charAt(0).toUpperCase() + segment.slice(1).replace(/-/g, ' ');\n  };\n  \n  // Fonction pour générer le chemin complet jusqu'à un segment\n  const getPathUpTo = (index) => {\n    return '/' + pathnames.slice(0, index + 1).join('/');\n  };\n  \n  return (\n    <div className=\"breadcrumbs-container\">\n      <MUIBreadcrumbs \n        separator={<NavigateNextIcon fontSize=\"small\" />}\n        aria-label=\"navigation hiérarchique\"\n      >\n        {/* Lien d'accueil toujours affiché */}\n        <MUILink \n          component={Link} \n          to=\"/\"\n          color=\"inherit\"\n          display=\"flex\"\n          alignItems=\"center\"\n          className=\"breadcrumb-link\"\n        >\n          <HomeIcon fontSize=\"small\" style={{ marginRight: '4px' }} />\n          Accueil\n        </MUILink>\n        \n        {/* Liens pour chaque segment du chemin */}\n        {pathnames.map((segment, index) => {\n          const path = getPathUpTo(index);\n          const routeInfo = routeConfig[path] || {};\n          const isLast = index === pathnames.length - 1;\n          \n          // Pour le dernier élément, afficher un texte non cliquable\n          if (isLast) {\n            return (\n              <Typography \n                key={path}\n                color=\"textPrimary\"\n                display=\"flex\"\n                alignItems=\"center\"\n                className=\"breadcrumb-current\"\n              >\n                {routeInfo.icon || null}\n                {routeInfo.label || getSegmentLabel(segment)}\n              </Typography>\n            );\n          }\n          \n          // Pour les autres éléments, afficher un lien\n          return (\n            <MUILink\n              key={path}\n              component={Link}\n              to={path}\n              color=\"inherit\"\n              display=\"flex\"\n              alignItems=\"center\"\n              className=\"breadcrumb-link\"\n            >\n              {routeInfo.icon || null}\n              {routeInfo.label || getSegmentLabel(segment)}\n            </MUILink>\n          );\n        })}\n      </MUIBreadcrumbs>\n    </div>\n  );\n};\n\nexport default Breadcrumbs;\n","/**\n * Service de configuration centrale pour les API\n * Ce fichier configure axios pour toutes les requêtes API\n */\nimport axios from 'axios';\n\n// Récupérer l'URL de base depuis les variables d'environnement\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';\nconst USE_MOCK_DATA = process.env.REACT_APP_USE_MOCK_DATA === 'true';\n\n// Création d'une instance axios avec la configuration de base\nconst api = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  // Ajouter un timeout par défaut pour éviter les requêtes bloquées indéfiniment\n  timeout: 30000, // 30 secondes\n  // Activer les credentials pour les cookies\n  withCredentials: true\n});\n\n// Intercepteur pour ajouter le token d'authentification JWT à chaque requête\napi.interceptors.request.use(\n  (config) => {\n    // Récupérer le token depuis les cookies ou localStorage\n    // Note: Les cookies httpOnly ne sont pas accessibles via JavaScript\n    // mais le token peut être stocké dans localStorage pour la compatibilité\n    const token = localStorage.getItem('authToken');\n    \n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // Ajouter un timestamp pour éviter la mise en cache des requêtes GET\n    if (config.method === 'get') {\n      config.params = {\n        ...config.params,\n        _t: Date.now()\n      };\n    }\n    \n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\n// Intercepteur pour gérer les réponses et les erreurs\napi.interceptors.response.use(\n  (response) => {\n    // Vérifier si la réponse contient un nouveau token d'accès\n    const newToken = response.headers['x-new-access-token'];\n    if (newToken) {\n      // Mettre à jour le token dans localStorage\n      localStorage.setItem('authToken', newToken);\n    }\n    \n    return response;\n  },\n  (error) => {\n    // Gérer les erreurs d'authentification (401)\n    if (error.response && error.response.status === 401) {\n      // Vérifier si l'erreur est due à un token expiré\n      const isTokenExpired = \n        error.response.data?.error?.type === 'auth_token_expired' ||\n        error.response.data?.message?.includes('expired');\n      \n      // Si le token est expiré, tenter de le rafraîchir automatiquement\n      // Cette logique sera gérée par le service d'authentification\n      \n      // Pour l'instant, déconnecter l'utilisateur\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('user');\n      \n      // Rediriger vers la page de connexion si nécessaire\n      if (window.location.pathname !== '/login') {\n        window.location.href = '/login?expired=true';\n      }\n    }\n    \n    // Gérer les erreurs de timeout\n    if (error.code === 'ECONNABORTED' && error.message.includes('timeout')) {\n      error.response = {\n        data: {\n          error: {\n            type: 'timeout_error',\n            message: 'La requête a pris trop de temps à s\\'exécuter',\n            severity: 'warning'\n          }\n        }\n      };\n    }\n    \n    // Gérer les erreurs réseau\n    if (!error.response) {\n      error.response = {\n        data: {\n          error: {\n            type: 'network_error',\n            message: 'Impossible de se connecter au serveur',\n            severity: 'warning',\n            details: error.message\n          }\n        }\n      };\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n/**\n * Fonction utilitaire pour créer des requêtes avec gestion de cache\n * @param {string} url - URL de la requête\n * @param {Object} options - Options de la requête\n * @returns {Promise} Promesse avec les données de la réponse\n */\nconst createCachedRequest = (url, options = {}) => {\n  const { cacheDuration = 5 * 60 * 1000, forceRefresh = false } = options;\n  \n  // Clé de cache unique pour cette requête\n  const cacheKey = `api_cache_${url}`;\n  \n  // Vérifier si les données sont en cache et toujours valides\n  const cachedData = localStorage.getItem(cacheKey);\n  if (cachedData && !forceRefresh) {\n    try {\n      const { data, timestamp } = JSON.parse(cachedData);\n      const isValid = Date.now() - timestamp < cacheDuration;\n      \n      if (isValid) {\n        return Promise.resolve(data);\n      }\n    } catch (error) {\n      // Ignorer les erreurs de parsing et continuer avec la requête\n      console.warn('Erreur lors de la lecture du cache:', error);\n    }\n  }\n  \n  // Effectuer la requête API\n  return api.get(url)\n    .then(response => {\n      // Mettre en cache les données\n      localStorage.setItem(cacheKey, JSON.stringify({\n        data: response.data,\n        timestamp: Date.now()\n      }));\n      \n      return response.data;\n    });\n};\n\nexport { api, USE_MOCK_DATA, createCachedRequest };\nexport default api;\n"],"names":["NotificationContext","createContext","useNotification","context","useContext","Error","ERROR_TYPE_MAPPING","type","title","severity","NOTIFICATION_CONFIG","critical","position","autoClose","closeButton","pauseOnHover","warning","info","constructor","this","notifyFn","errorStats","count","byType","byEndpoint","setupApiInterceptor","init","console","log","api","interceptors","response","use","error","handleApiError","Promise","reject","errorData","message","details","data","notification","trackError","notifyError","originalError","config","url","endpoint","warn","errorTypeConfig","default","severityConfig","notificationConfig","undefined","duration","handleError","options","arguments","length","getErrorStats","resetErrorStats","useErrorHandler","notify","useEffect","errorService","handleApiRequest","useCallback","async","promise","successMessage","loadingMessage","errorMessage","showSuccess","showLoading","onSuccess","onError","loadingId","result","removeNotification","success","_error$response","_error$response$data","_error$response$data$","tryCatch","fn","showError","fallbackValue","handleFormError","setError","_error$response2","_error$response2$data","_error$response2$data2","validationErrors","Object","entries","forEach","_ref","field","bind","routeConfig","label","icon","_jsx","HomeIcon","fontSize","TerrainIcon","DirectionsBikeIcon","RestaurantIcon","MapIcon","PeopleIcon","PersonIcon","SettingsIcon","BugReportIcon","segmentConfig","Breadcrumbs","pathnames","useLocation","pathname","split","filter","x","getSegmentLabel","segment","test","charAt","toUpperCase","slice","replace","className","children","_jsxs","MUIBreadcrumbs","separator","NavigateNextIcon","MUILink","component","Link","to","color","display","alignItems","style","marginRight","map","index","path","join","getPathUpTo","routeInfo","Typography","axios","create","baseURL","process","headers","timeout","withCredentials","request","token","localStorage","getItem","Authorization","method","params","_t","Date","now","newToken","setItem","status","_error$response$data2","_error$response$data3","includes","removeItem","window","location","href","code"],"sourceRoot":""}